# 汇编语言

# 第1章 基础知识

汇编是直接在硬件之上的编程语言. 本笔记教材是王爽的 汇编语言.

这一章主要回顾的是组成原理.

## 机器语言

汇编的诞生不得不提机器语言. 机器语言就是机器指令的集合即指令集. 机器指令请看组成原理. 

涉及到的CPU也移步组成原理.

不同处理器, 硬件设计跟内部结构不同, 就要用不同的电平脉冲来控制.故每种处理器都有自己的指令集, 就是机器语言.

## 汇编语言诞生

汇编的主体部分就是**汇编指令**.

汇编指令跟机器指令的区别, 就在指令的表示方法上. 汇编指令是机器指令便于记忆的书写格式(助记符).

汇编指令是机器指令的助记符.

例如:

```text
机器指令: 1000100111011000
操作: 寄存器BX的内容送到AX中
汇编指令: MOV AX,BX
这样的写法与人类语言接近,便于阅读和记忆.
```

> 提到了`寄存器`: 简单的讲是CPU中可以存储数据的器件, 一个CPU中有多个寄存器.
> AX是其中一个寄存器的代号, BX是另一个寄存器的代号.

计算机能读懂的只有`机器指令`, 那么如何让计算机执行程序员用汇编指令编写的程序呢？

![1671422024601](Asm_lang.assets/1671422024601.png)

> 写完汇编程序, 再用`编译器`翻译成机器认识的机器指令就行了.

## 汇编语言的组成

编语言由以下3类组成：

1. 汇编指令(机器码的助记符, 有对应机器码)
2. 伪指令   (由编译器执行, 无对应机器码所以计算机不执行)
3. 其它符号 (如加减乘除符号, 由编译器识别, 无对应机器码)

汇编语言的核心是**汇编指令**, 它决定汇编语言的特性.

## 存储器

CPU是计算机的核心部件, 它控制整个计算机的运作并进行运算, 要想让一个CPU 工作, 就必须向它提供指令和数据. 

指令和数据在存储器中存放, 也就是平时所说的内存. 内存的作用仅次于CPU.

磁盘与内存的区别, 看组成原理. 存储器这一块属于组成原理.

## 指令与数据

继续是组成原理的内容.

按照冯诺依曼结构, 指令和数据都存放在存储器中, 在内存中指令与数据是一样的二进制, 但放的位置不同.

> 二进制信息:1000100111011000  计算机可以视为89D8H(数据) 也可以视为MOV AX,BX (程序)

## 存储单元

去看组成原理. 

存储器被分为若干单元, 每个单元能存储若干二进制的信息.

## CPU对存储器的读写

CPU要进行数据的读写, 必须和外部器件(芯片), 进行三类信息交互:

1. 存储单元的地址信息.
2. 器件的选择, 读或写的命令, 控制信息.
3. 要读或写的数据, 数据信息.

CPU通过 地址总线, 控制总线, 数据总线传输信息. 具体看组成原理.

![1671424306258](Asm_lang.assets/1671424306258.png)

读过程:

1. CPU通过地址总线把地址信息3发送到MAR中.
2. CPU通过控制总线把1→R 发送到内存, 片选信号选中存储器芯片, 控制它取出数据到MDR
3. 内存把MDR的数据通过数据总线送到CPU内的寄存器中.

写过程类似.

从上面我们知道CPU是如何进行数据读写的. 可是我们如何命令计算机进行数据的读写呢？

对于8086CPU, 下面的机器码能够完成从3号单元读数据:
机器码: 101000010000001100000000
含义: 从3号单元读取数据送入寄存器AX
CPU接收这条机器码后将完成上面所述的读写工作.

这么长的程序谁记得住, 写成汇编:
机器码: 10100001 00000011 00000000
对应汇编: MOV AX,[3]
含义: 从3号单元读取数据送入寄存器AX

## 系统总线

看组成原理的BUS总线部分, 数据总线, 地址总线, 控制总线.

一个CPU有N条地址线, 就有CPU地址总线的宽度为N. CPU最多可以寻找2的N次方个内存单元.

数据总线的宽度决定CPU与外界的数据传送速度.

CPU对外控制是通过控制总线来进行的. 在这里控制总线是个总称, 是一些不同控制线的集合.

有多少根控制总线, 就意味着CPU提供了对外部器件的多少种控制.

控制总线的宽度决定了CPU对外部器件的控制能力.

## 主板

主板上有核心器件和一些主要器件, 他们通过总线相连. 

## 接口卡

CPU对外部设备都不能直接控制, 如显示器, 音响, 打印机等. 直接控制这些设备进行工作的是插在扩展插槽上的接口卡. 扩展插槽通过总线和CPU相连, 所以接口卡也通过总线与CPU相连. CPU可以直接控制这些接口卡, 从而实现CPU对外设的间接控制.

> CPU通过总线向接口卡发送命令, 接口卡根据CPU的命令控制外设工作.

## 各类存储器芯片

RAM ROM

从功能和连接上分类：

- 随机存储器RAM
- 装有BIOS的ROM
- 接口卡上的RAM(如显存)

![1671436378759](Asm_lang.assets/1671436378759.png)

## 内存地址空间

上述的那些存储器在物理上是独立的器件. 
但是它们在以下两点上相同：
 1、都和CPU的总线相连.
 2、CPU对它们进行读或写的时候都通过控制线发出内存读写命令.

CPU把它们都当做内存来看, 将它们总的看作一个由若干存储单元组成的逻辑存储器.

这个逻辑存储器就是我们所说的内存地址空间. 也是汇编在面对的内存地址空间.

![1671436619429](Asm_lang.assets/1671436619429.png)

上图所有的物理存储器被看作一个整体的逻辑存储器, 每个物理存储器在此逻辑存储器中占一个地址段, 即一段地址空间. CPU在这段地址段中读写数据, 实际上就是在想对应的物理存储器中读写数据.

假设，上图中的内存空间地址段分配如下：

地址0~7FFFH的32KB空间为主随机存储器的地址空间；
地址8000H~9FFFH的8KB空间为显存地址空间；
地址A000H~FFFFH的24KB空间为各个ROM的地址空间.

**不同的计算机系统的内存地址空间分配情况是不同的.**

![1671437126791](Asm_lang.assets/1671437126791.png)

内存地址空间:
最终运行程序的是CPU, 我们用汇编编程的时候, 必须要从CPU角度考虑问题.
对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中, 它的容量受CPU寻址能力的限制. 这个逻辑存储器即是我们所说的内存地址空间.

# 第2章 寄存器

CPU = 运算器 + 控制器 + 寄存器. 这些器件靠CPU内部总线相连.

内部总线实现CPU内部各个器件之间的联系.

外部总线实现CPU和主板上其它器件的联系.

CPU内部: 

- 运算器进行数据处理
- 寄存器进行信息存储
- 控制器控制各器件进行工作
- 内部总线连接各种器件, 在他们之间进行数据的传送.

对一个汇编程序员来说, CPU中的主要部件是寄存器. 它是CPU中程序员可以用指令读写的器件. 程序员通过改变各种寄存器中的内容来实现对CPU的控制.

不同CPU, 寄存器个数, 结构是不一样的. 8086CPU有14个寄存器: AX,BX, CX, DX SI DI SP BP IP CS SS DS ES PSW.

## 通用寄存器

8086CPU所有的寄存器都是**16位**的, 可以存放两个字节.
AX, BX, CX, DX 通常用来存放**一般性数据**被称为**通用寄存器.**

![1671439715934](Asm_lang.assets/1671439715934.png)

为了兼容上一代CPU的8位寄存器.

8086CPU的这几个通用寄存器把16位劈开成两个8位用.

AX 分成AH, AL. BX, CX, DX都一样.

![1671439922557](Asm_lang.assets/1671439922557.png)

> AX的低8位(0位\~7位)构成了AL寄存器, 高8位(8位\~15位)构成了AH寄存器.
> AH和AL寄存器是可以独立使用的8位寄存器.

## 字在寄存器中的存储

出于兼容性, 8086CPU可以一次处理以下两种尺寸的数据.

- 字节: byte, 8个bit.
- 字: word, 16个bit. 两个字节, 高字节, 低字节.

![1671440604311](Asm_lang.assets/1671440604311.png)

高字节跟低字节可以合起来看作一个整体, 也可以各自视为一个整体.

## 数制

不讨论了, 组成原理讲过太简单.

## 几条汇编指令

![1671444151374](Asm_lang.assets/1671444151374.png)

**汇编指令或者寄存器名`不区分大小写`**.

![1671445369299](Asm_lang.assets/1671445369299.png)	

> 16位所以是044CH, 进位的那个1, 之后讨论.

![1671445624111](Asm_lang.assets/1671445624111.png)

> 这个结果是, 0058H, 因为这里AL作为一个整体只有8位, 不会去用AH的数据位.
>
> 但如果最后一条指令是 add ax,93H,  那ax里就是0158H了.因为用的是ax16位的.

![1671446751310](Asm_lang.assets/1671446751310.png)

> 上面都是`错误`的指令. 因为会溢出.

## 物理地址

CPU访问内存单元时要给出内存单元的地址. 所有的内存单元构成的存储空间是一个一维的线性空间.
每个内存单元在这个空间都有唯一的地址, 我们将这个唯一的地址称为**物理地址**.

CPU通过地址总线送入存储器的, 必须是一个内存单元的物理地址. 那在CPU发出物理地址之前, 必须要先在内部形成这个物理地址.

不同的CPU形成物理地址的方式可以不尽相同.  本学习是8086CPU.

## 16位结构的CPU

概括的讲, 16位结构描述了一个CPU具有以下几个方面特征:

1. 运算器一次最多可以处理16位的数据.
2. 寄存器的最大宽度为16位.
3. 寄存器和运算器之间的通路是16位的.

8086就是16位机, 8086一次性可以处理,传输, 暂存的信息最长 16位. 内存单元地址也必须在8086中处理,传输,暂存.

## 8086给出物理地址的方法

8086有20位地址总线, 可传送20位地址, 寻址能力为1M.

8086内部为16位结构, 它只能传送16位的地址, 表现出的寻址能力却只有64K.

8086CPU采用一种在内部**用两个16位地址合成的方法**来形成一个20位的物理地址.

![1671449544647](Asm_lang.assets/1671449544647.png)

如上图, 当8086要读写内存时:

1. CPU中的相关部件提供两个16位的地址, 一个称为段地址, 另一个称为偏移地址;
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;
3. 地址加法器将两个16位地址合并成一个20位的物理地址;
4. 地址加法器通过内部总线把20位物理地址送入输入输出控制电路;
5. 输入输出控制电路将20位物理地址送上地址总线.
6. 20位物理地址被地址总线传到存储器.

地址加法器合成物理地址的方法：
         **物理地址=段地址×16+偏移地址**

![1671455048049](Asm_lang.assets/1671455048049.png)

> “段地址×16”有一个更为常用的说法就是数据左移4位(二进制位).
>
> ![1671455620170](Asm_lang.assets/1671455620170.png)

## "物理地址=段地址×16+偏移地址"的本质

本质含义: CPU在访问内存时, 用一个**基础地址**(段地址x16)和一个相对于基础地址的**偏移地址**相加, 给出内存单元的物理地址.

这种寻址功能就是 **基础地址+偏移地址 = 物理地址**.(具体看组成原理.)寻址模式的一种具体实现方案. 这里段地址左移4位可以看作一个基地址.

## 段的概念

内存没有被分段, **段的划分是来自CPU**, 由于8086CPU用"(段地址×16)+偏移地址=物理地址"的方式给出内存单元的物理地址, 使得我们可以**用分段的方式来管理内存.**

![1671457945850](Asm_lang.assets/1671457945850.png)

> 左边的基础地址是10000H, 段地址就是1000H.右边有两个段, 两个基础地址分别为10000H 和 10080H. 那么他们的段地址分别为 1000H和1008H.

以后, 在编程时可以**根据需要**, **将若干地址连续的内存单元看作一个段**, 用段地址x16定位段的起始地址(基础地址), 用偏移地址定位段中的内存单元.

注意点:

- 段地址x16比然是16的倍数, 所以一个段的起始地址也一定是16的倍数.

- 偏移地址为16位, 16位地址的**寻址能力**为64KB, 所以**一个段的长度最大64KB.**

## 内存单元地址小结

CPU访问内存单元时必须向内存提供内存单元的物理地址.

8086在内部用段地址和偏移地址移位相加形成最终的物理地址.

看:

| 物理地址 | 段地址 | 偏移地址 |
| :------: | :----: | :------: |
|  21F60H  | 2000H  |  1F60H   |
|          | 2100H  |  0F60H   |
|          | 21F0H  |  0060H   |
|          | 21F6H  |  0000H   |
|          | 1F00H  |  2F60H   |

> 结论: CPU可以用不同的段地址和偏移地址来形成同一个物理地址.
>
> 只需要满足段地址SA和偏移地址EA满足 SAx16+EA = 要访问的地址

另一个问题: 若给定一个段地址, 仅通过变化偏移地址来进行寻址, 最多可定位多少个内存单元.

结论: 偏移地址16位, 范围0\~FFFFH, 答案就是64K个内存单元.

如, 给定段地址1000H, 用偏移地址寻址, CPU的寻址范围位: 10000H\~1FFFFH.

在8086机中, 存储单元的地址用两个元素来描述, 段地址和偏移地址.

21F60H 这个地址 在8086中表述为 2000:1F60. 或者 2000H段中的1F60H单元

可以根据需要, 将**地址连续, 起始地址是16倍数**的**一组内存单元**定义为一个段.

