# 汇编语言

> 王爽 汇编语言第四版

# 第1章 基础知识

汇编是直接在硬件之上的编程语言. 本笔记教材是王爽的 汇编语言.

这一章主要回顾的是组成原理.

## 机器语言

汇编的诞生不得不提机器语言. 机器语言就是机器指令的集合即指令集. 机器指令请看组成原理. 

涉及到的CPU也移步组成原理.

不同处理器, 硬件设计跟内部结构不同, 就要用不同的电平脉冲来控制.故每种处理器都有自己的指令集, 就是机器语言.

## 汇编语言诞生

汇编的主体部分就是**汇编指令**.

汇编指令跟机器指令的区别, 就在指令的表示方法上. 汇编指令是机器指令便于记忆的书写格式(助记符).

汇编指令是机器指令的助记符.

例如:

```text
机器指令: 1000100111011000
操作: 寄存器BX的内容送到AX中
汇编指令: MOV AX,BX
这样的写法与人类语言接近,便于阅读和记忆.
```

> 提到了`寄存器`: 简单的讲是CPU中可以存储数据的器件, 一个CPU中有多个寄存器.
> AX是其中一个寄存器的代号, BX是另一个寄存器的代号.

计算机能读懂的只有`机器指令`, 那么如何让计算机执行程序员用汇编指令编写的程序呢？

![1671422024601](Asm_lang.assets/1671422024601.png)

> 写完汇编程序, 再用`编译器`翻译成机器认识的机器指令就行了.

## 汇编语言的组成

编语言由以下3类组成：

1. 汇编指令(机器码的助记符, 有对应机器码)
2. 伪指令   (由编译器执行, 无对应机器码所以计算机不执行)
3. 其它符号 (如加减乘除符号, 由编译器识别, 无对应机器码)

汇编语言的核心是**汇编指令**, 它决定汇编语言的特性.

## 存储器

CPU是计算机的核心部件, 它控制整个计算机的运作并进行运算, 要想让一个CPU 工作, 就必须向它提供指令和数据. 

指令和数据在存储器中存放, 也就是平时所说的内存. 内存的作用仅次于CPU.

磁盘与内存的区别, 看组成原理. 存储器这一块属于组成原理.

## 指令与数据

继续是组成原理的内容.

按照冯诺依曼结构, 指令和数据都存放在存储器中, 在内存中指令与数据是一样的二进制, 但放的位置不同.

> 二进制信息:1000100111011000  计算机可以视为89D8H(数据) 也可以视为MOV AX,BX (程序)

## 存储单元

去看组成原理. 

存储器被分为若干单元, 每个单元能存储若干二进制的信息.

## CPU对存储器的读写

CPU要进行数据的读写, 必须和外部器件(芯片), 进行三类信息交互:

1. 存储单元的地址信息.
2. 器件的选择, 读或写的命令, 控制信息.
3. 要读或写的数据, 数据信息.

CPU通过 地址总线, 控制总线, 数据总线传输信息. 具体看组成原理.

![1671424306258](Asm_lang.assets/1671424306258.png)

读过程:

1. CPU通过地址总线把地址信息3发送到MAR中.
2. CPU通过控制总线把1→R 发送到内存, 片选信号选中存储器芯片, 控制它取出数据到MDR
3. 内存把MDR的数据通过数据总线送到CPU内的寄存器中.

写过程类似.

从上面我们知道CPU是如何进行数据读写的. 可是我们如何命令计算机进行数据的读写呢？

对于8086CPU, 下面的机器码能够完成从3号单元读数据:
机器码: 101000010000001100000000
含义: 从3号单元读取数据送入寄存器AX
CPU接收这条机器码后将完成上面所述的读写工作.

这么长的程序谁记得住, 写成汇编:
机器码: 10100001 00000011 00000000
对应汇编: MOV AX,[3]
含义: 从3号单元读取数据送入寄存器AX

## 系统总线

看组成原理的BUS总线部分, 数据总线, 地址总线, 控制总线.

一个CPU有N条地址线, 就有CPU地址总线的宽度为N. CPU最多可以寻找2的N次方个内存单元.

数据总线的宽度决定CPU与外界的数据传送速度.

CPU对外控制是通过控制总线来进行的. 在这里控制总线是个总称, 是一些不同控制线的集合.

有多少根控制总线, 就意味着CPU提供了对外部器件的多少种控制.

控制总线的宽度决定了CPU对外部器件的控制能力.

## 主板

主板上有核心器件和一些主要器件, 他们通过总线相连. 

## 接口卡

CPU对外部设备都不能直接控制, 如显示器, 音响, 打印机等. 直接控制这些设备进行工作的是插在扩展插槽上的接口卡. 扩展插槽通过总线和CPU相连, 所以接口卡也通过总线与CPU相连. CPU可以直接控制这些接口卡, 从而实现CPU对外设的间接控制.

> CPU通过总线向接口卡发送命令, 接口卡根据CPU的命令控制外设工作.

## 各类存储器芯片

RAM ROM

从功能和连接上分类：

- 随机存储器RAM
- 装有BIOS的ROM
- 接口卡上的RAM(如显存)

![1671436378759](Asm_lang.assets/1671436378759.png)

## 内存地址空间

上述的那些存储器在物理上是独立的器件. 
但是它们在以下两点上相同:
 1, 都和CPU的总线相连.
 2, CPU对它们进行读或写的时候都通过控制线发出内存读写命令.

CPU把它们都当做内存来看, 将它们总的看作一个由若干存储单元组成的逻辑存储器.

这个逻辑存储器就是我们所说的内存地址空间. 也是汇编在面对的内存地址空间.

![1671436619429](Asm_lang.assets/1671436619429.png)

上图所有的物理存储器被看作一个整体的逻辑存储器, 每个物理存储器在此逻辑存储器中占一个地址段, 即一段地址空间. CPU在这段地址段中读写数据, 实际上就是在想对应的物理存储器中读写数据.

假设, 上图中的内存空间地址段分配如下：

地址0~7FFFH的32KB空间为主随机存储器的地址空间；
地址8000H~9FFFH的8KB空间为显存地址空间；
地址A000H~FFFFH的24KB空间为各个ROM的地址空间.

**不同的计算机系统的内存地址空间分配情况是不同的.**

![1671437126791](Asm_lang.assets/1671437126791.png)

内存地址空间:
最终运行程序的是CPU, 我们用汇编编程的时候, 必须要从CPU角度考虑问题.
对CPU来讲, 系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中, 它的容量受CPU寻址能力的限制. 这个逻辑存储器即是我们所说的内存地址空间.

# 第2章 寄存器

CPU = 运算器 + 控制器 + 寄存器. 这些器件靠CPU内部总线相连.

内部总线实现CPU内部各个器件之间的联系.

外部总线实现CPU和主板上其它器件的联系.

CPU内部: 

- 运算器进行数据处理
- 寄存器进行信息存储
- 控制器控制各器件进行工作
- 内部总线连接各种器件, 在他们之间进行数据的传送.

对一个汇编程序员来说, CPU中的主要部件是寄存器. 它是CPU中程序员可以用指令读写的器件. 程序员通过改变各种寄存器中的内容来实现对CPU的控制.

不同CPU, 寄存器个数, 结构是不一样的. 8086CPU有14个寄存器: AX,BX, CX, DX SI DI SP BP IP CS SS DS ES PSW.

## 通用寄存器

8086CPU所有的寄存器都是**16位**的, 可以存放两个字节.
AX, BX, CX, DX 通常用来存放**一般性数据**被称为**通用寄存器.**

![1671439715934](Asm_lang.assets/1671439715934.png)

为了兼容上一代CPU的8位寄存器.

8086CPU的这几个通用寄存器把16位劈开成两个8位用.

AX 分成AH, AL. BX, CX, DX都一样.

![1671439922557](Asm_lang.assets/1671439922557.png)

> AX的低8位(0位\~7位)构成了AL寄存器, 高8位(8位\~15位)构成了AH寄存器.
> AH和AL寄存器是可以独立使用的8位寄存器.

## 字在寄存器中的存储

出于兼容性, 8086CPU可以一次处理以下两种尺寸的数据.

- 字节: byte, 8个bit.
- 字: word, 16个bit. 两个字节, 高字节, 低字节.

![1671440604311](Asm_lang.assets/1671440604311.png)

高字节跟低字节可以合起来看作一个整体, 也可以各自视为一个整体.

## 数制

不讨论了, 组成原理讲过太简单.

## 几条汇编指令

![1671444151374](Asm_lang.assets/1671444151374.png)

**汇编指令或者寄存器名`不区分大小写`**.

![1671445369299](Asm_lang.assets/1671445369299.png)	

> 16位所以是044CH, 进位的那个1, 之后讨论.

![1671445624111](Asm_lang.assets/1671445624111.png)

> 这个结果是, 0058H, 因为这里AL作为一个整体只有8位, 不会去用AH的数据位.
>
> 但如果最后一条指令是 add ax,93H,  那ax里就是0158H了.因为用的是ax16位的.

![1671446751310](Asm_lang.assets/1671446751310.png)

> 上面都是`错误`的指令. 因为会溢出.

## 物理地址

CPU访问内存单元时要给出内存单元的地址. 所有的内存单元构成的存储空间是一个一维的线性空间.
每个内存单元在这个空间都有唯一的地址, 我们将这个唯一的地址称为**物理地址**.

CPU通过地址总线送入存储器的, 必须是一个内存单元的物理地址. 那在CPU发出物理地址之前, 必须要先在内部形成这个物理地址.

不同的CPU形成物理地址的方式可以不尽相同.  本学习是8086CPU.

## 16位结构的CPU

概括的讲, 16位结构描述了一个CPU具有以下几个方面特征:

1. 运算器一次最多可以处理16位的数据.
2. 寄存器的最大宽度为16位.
3. 寄存器和运算器之间的通路是16位的.

8086就是16位机, 8086一次性可以处理,传输, 暂存的信息最长 16位. 内存单元地址也必须在8086中处理,传输,暂存.

## 8086给出物理地址的方法

8086有20位地址总线, 可传送20位地址, 寻址能力为1M.

8086内部为16位结构, 它只能传送16位的地址, 表现出的寻址能力却只有64K.

8086CPU采用一种在内部**用两个16位地址合成的方法**来形成一个20位的物理地址.

![1671449544647](Asm_lang.assets/1671449544647.png)

如上图, 当8086要读写内存时:

1. CPU中的相关部件提供两个16位的地址, 一个称为**段地址**, 另一个称为**偏移地址;**
2. 段地址和偏移地址通过**内部总线**送入一个称为**地址加法器**的部件;
3. **地址加法器将两个16位地址合并成一个20位的物理地址;**
4. 地址加法器通过**内部总线**把20位物理地址送入**输入输出控制电路**;
5. 输入输出控制电路将20位物理地址送上**地址总线**.
6. 20位物理地址被地址总线传到**存储器**.

地址加法器合成物理地址的方法：
         **物理地址=段地址×16+偏移地址**

![1671455048049](Asm_lang.assets/1671455048049.png)

> “段地址×16”有一个更为常用的说法就是数据左移4位(二进制位).
>
> ![1671455620170](Asm_lang.assets/1671455620170.png)

## "物理地址=段地址×16+偏移地址"的本质

本质含义: CPU在访问内存时, 用一个**基础地址**(`段地址x16`)和一个相对于基础地址的**偏移地址**相加, 给出内存单元的物理地址.

这种寻址功能就是 **基础地址+偏移地址 = 物理地址**.(具体看组成原理.)寻址模式的一种具体实现方案. 这里段地址左移4位可以看作一个基地址.

## 段的概念

内存没有被分段, **段的划分是来自CPU**, 由于8086CPU用"(段地址×16)+偏移地址=物理地址"的方式给出内存单元的物理地址, 使得我们可以**用分段的方式来管理内存.**

![1671457945850](Asm_lang.assets/1671457945850.png)

> 左边的基础地址是10000H, 段地址就是1000H.右边有两个段, 两个基础地址分别为10000H 和 10080H. 那么他们的段地址分别为 1000H和1008H.

以后, 在编程时可以**根据需要**, **将若干地址连续的内存单元看作一个段**, 用段地址x16定位段的起始地址(基础地址), 用偏移地址定位段中的内存单元.

注意点:

- 段地址x16比然是16的倍数, 所以一个段的起始地址也一定是16的倍数.

- 偏移地址为16位, 16位地址的**寻址能力**为64KB, 所以**一个段的长度最大64KB.**

## 内存单元地址小结

CPU访问内存单元时必须向内存提供内存单元的物理地址.

8086在内部用段地址和偏移地址移位相加形成最终的物理地址.

看:

| 物理地址 | 段地址 | 偏移地址 |
| :------: | :----: | :------: |
|  21F60H  | 2000H  |  1F60H   |
|          | 2100H  |  0F60H   |
|          | 21F0H  |  0060H   |
|          | 21F6H  |  0000H   |
|          | 1F00H  |  2F60H   |

> 结论: CPU可以用不同的段地址和偏移地址来形成同一个物理地址.
>
> 只需要满足段地址SA和偏移地址EA满足 SAx16+EA = 要访问的地址

另一个问题: 若给定一个段地址, 仅通过变化偏移地址来进行寻址, 最多可定位多少个内存单元.

结论: 偏移地址16位, 范围0\~FFFFH, 答案就是64K个内存单元.

如, 给定段地址1000H, 用偏移地址寻址, CPU的寻址范围位: 10000H\~1FFFFH.

在8086机中, 存储单元的地址用两个元素来描述, 段地址和偏移地址.

21F60H 这个地址 在8086中表述为 2000:1F60. 或者 2000H段中的1F60H单元

可以根据需要, 将**地址连续, 起始地址是16倍数**的**一组内存单元**定义为一个段.	

## 段寄存器

上面说到, 8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址, 送入地址加法器合成物理地址.

那是什么部件提供段地址的呢? 

**段地址存放在8086CPU的段寄存器中.**

8086CPU有**4个段寄存器:** `CS, DS, SS, ES`. CPU要访问内存时, 由此4个寄存器提供内存单元的段地址.

> CS: Code Segment; DS: Data Segment; SS: Stack Segment; ES: Extra Segment; 

## CS和IP

CS和IP是8086CPU中最关键的两个寄存器了. **它们指示了CPU当前读取指令的地址.**

CS是**代码段寄存器**, IP是**指令指针寄存器**.

在8086机器中, 任意时刻, 设CS中的内容为M, IP中的内容为N, 8086CPU将从**内存Mx16+N单元开始**, **读取一条指令并执行.** 

> Code Segment 代码段, 其实就是指令段.

换种表述: 8086机器中, 任意时刻, CPU将CS:IP指向的内容当做指令执行.	

下图展示了8086机读取,执行指令的工作过程.(图中数据皆为16进制)	

![1671517867858](Asm_lang.assets/1671517867858.png)

上图说明:

1. 8086CPU当前状态: CS中内容是2000H, IP是0000H

2. 内存20000H\~20009H 单元存放着可执行的机器码;

3. 机器码对应的汇编指令:

   地址: 20000H\~20002H, 内容: B8 23 01, 长度: 3Byte. 对应汇编: mov ax, 0123H.

   地址: 20003H\~20005H, 内容: BB 03 00, 长度: 3Byte. 对应汇编: mov bx, 0003H.

   地址: 20006H\~20007H, 内容: 89 D8, 长度: 2Byte. 对应汇编: mov ax, bx.

   地址: 20008H\~20009H, 内容: 01 D8, 长度: 2Byte. 对应汇编: add ax, bx.

![1671519174936](Asm_lang.assets/1671519174936.png)

![1671519195806](Asm_lang.assets/1671519195806.png)

![1671519228141](Asm_lang.assets/1671519228141.png)

![1671519282544](Asm_lang.assets/1671519282544.png)

![1671519298958](Asm_lang.assets/1671519298958.png)

![1671519316063](Asm_lang.assets/1671519316063.png)

![1671519336611](Asm_lang.assets/1671519336611.png)

![1671519365006](Asm_lang.assets/1671519365006.png)

![1671519385168](Asm_lang.assets/1671519385168.png)

![1671519443149](Asm_lang.assets/1671519443149.png)

![1671519461284](Asm_lang.assets/1671519461284.png)

![1671519472436](Asm_lang.assets/1671519472436.png)

![1671519481057](Asm_lang.assets/1671519481057.png)

![1671519493006](Asm_lang.assets/1671519493006.png)

![1671519548535](Asm_lang.assets/1671519548535.png)

![1671519564772](Asm_lang.assets/1671519564772.png)

上面这些过程, 简述如下:

1. 从CS:IP指向内存单元读取指令, 读取的指令进入指令缓冲器;
2. **IP = IP + `所读取指令的长度`**, **从而指向下一条指令**; 
3. 执行指令.  转到步骤 (1), 重复这个过程.

**在 8086CPU 加电启动或复位后**(即CPU刚开始工作时)CS和IP被设置为**CS=FFFFH, IP=0000H**, 即在8086PC机刚启动时, **CPU从内存FFFF0H单元中读取指令执行, `FFFF0H单元中的指令是8086PC机开机后执行的第一条指令`**.

之前说过, 在内存中, 指令与数据没有任何区别, 都是二进制信息, CPU在工作的时候把有的信息看作指令, 而有的看做数据. 那CPU根据上面将内存中的信息看作指令? 我们可以说, CPU将CS:IP指向的内存单元中的内容看作指令. 

因为 在任何时候, CPU将CS, IP中的内容当作指令的段地址和偏移地址, 用它们合成指令的物理地址, 到内存中读取指令码, 执行.

如果说, 内存中的一段信息曾被CPU执行过的话, 那么,它所在的内存单元必然被CS:IP指向过.

## 修改CS, IP的指令

在CPU中, 程序员能够用指令读写的部件, 只有寄存器, 可以通过改变寄存器中的内容实现对CPU的控制. CPU从何处

执行指令是由CS, IP中的内容决定的, 程序员可以通过改变CS, IP中的内容来控制CPU执行目标指令.

我们之前改通用寄存器的值是用mov 指令. 但mov不能用于设置CS, IP. 原因很简单, 8086CPU没提供这样的功能.

8086CPU中, 能改变CS, IP的内容的指令, 被统称为**转移指令.** 比如**jmp指令**.

若想**同时修改CS, IP的内容**, 可用"jmp 段地址:偏移地址"的指令完成. 如:

jmp 2AE3:3, 执行后: CS=2AE3H, IP=0003H,  CPU从2AE33H地址处取指令.

jmp 3:0B16, 执行后: CS=0003H, IP=0B16H, CPU从00B46H处读取指令.

**`"jmp 段地址:偏移地址" 指令的功能为: 用指令中给出的段地址修改CS, 偏移地址修改IP.`**

**只想修改IP的内容**, 可用**"jmp 某一合法寄存器"**的指令完成, 如:

jmp ax, 指令执行前, ax=1000H, CS=2000H, IP=0003H, 执行后:

ax=1000H, CS=2000H, **IP=1000H**.    只有IP的内容被ax中内容覆盖. 

jmp bx, 执行前, bx=0B16H, CS=2000H, IP=0003H. 

执行后, bx=0B16H, CS=2000H, **IP=0B16H.** 

**`"jmp 某一合法寄存器"指令功能为: 用该寄存器里的值修改IP.`**

![1671592403969](Asm_lang.assets/1671592403969.png)

他的执行流程:

1. mov ax,6622H
2. jmp 1000:3
3. mov ax,0000
4. mov bx, ax
5. jmp bx
6. mov ax,0123H
7. 转第三步.

## 代码段

对8086PC机, 编程时可以根据需要, 将一组内存单元定义为一个段. 可以将长度为 N(N≤64KB)的一组代码, 存在一组地址连续, 起始地址为16的倍数的内存单元中, 这段内存是用来存放代码的, 从而定义了一个**代码段**.

比如,将:

1. mov ax,0000
2. mov ax,0123H
3. mov bx, ax
4. jmp bx

这段长度为10字节的字节的指令, 存在从123B0H\~123B9H的一组内存单元中, 我们就可以认为, 123B0H\~123B9H**这段内存单元是用来存放代码的**, **是一个代码段**, 它的段地址为123BH, 长度为10字节.

如何使得代码段中的指令被执行呢？
将一段内存当作代码段, 仅仅是我们在编程时的一种安排, CPU 并不会由于这种安排, 就自动地将我们定义得代码段中的指令当作指令来执行.

**CPU只认被 CS:IP 指向的内存单元中的内容为指令**, 所以想要CPU执行我们放在代码段中的指令, 就**要将CS:IP指向所定义的代码段中的第一条指令的首地址.**
如刚才的CS = 123BH, IP = 0000H.

**2.9节~2.12节 小结**

1. 段地址在8086CPU的寄存器中存放. 当8086CPU要访问内存时, 由段寄存器提供内存单元的段地址. 8086CPU有4个段寄存器, 其中CS用来存放指令的段地址. 
2. CS存放指令的段地址, IP存放指令的偏移地址. 8086机中, 任意时刻, CPU将CS:IP指向的内容当作指令执行.
3. 8086CPU的工作过程：
   (1)从CS:IP指向内存单元读取指令, 读取的指令进入指令缓冲器;
   (2)IP指向下一条指令；
   (3)执行指令.(转到步骤(1), 重复这个过程.)
4. 8086CPU提供转移指令修改CS, IP的内容.

![1671594970972](Asm_lang.assets/1671594970972.png)

mov指令读取完, IP增加, SUB指令读取完, IP增加, JMP指令读取完, IP增加, JMP指令执行, IP被修改.

## 实验一

看书跟着做. win 10的debug百度搜.

![1671606716245](Asm_lang.assets/1671606716245.png)

![1671607184489](Asm_lang.assets/1671607184489.png)

# 第3章 寄存器(内存访问)

第2章主要是从CPU如何执行指令的角度了解8086CPU的逻辑结构, 形成物理地址的方法, 相关的寄存器以及一些指令.

## 内存中字的存储

CPU里的寄存器, 高八位存高字节, 低八位存低字节, 16位存一个字.

内存中呢, 内存单元是字节单元(一单元存一个字节0), 那一个字就用连续的两个内存单元放, 低字节放低地址中, 

高字节放高地址中.

![1671614784243](Asm_lang.assets/1671614784243.png)

上面就是存放4E20H, 跟0012H的内存分布. 0号单元是低地址单元, 1号单元是高地址单元.

> 字单元的概念: 字单元, 即存放一个字型数据(16位)的内存单元, 由两个地址连续的内存单元组成. 高地址内存单元存放高字节, 低地址内存单元存放低字节.

**将起始地址为N的`字单元`简称为N地址字单元.**

任何两个地址连续的内存单元, N号单元和N+1号单元, 可以将它们看成两个内存单元, 也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元.

## DS和[address]

CPU要读取一个内存单元的时候, 必须先给出这个内存单元的地址;
在8086PC中, 内存地址由段地址和偏移地址组成.
8086CPU中有一个DS寄存器, 通常用来存放要访问的数据的段地址.

例如:我们要读取10000H单元的内容可以用如下程序段进行:
```    asm
mov bx,1000H
mov ds,bx
mov al,[0]
```
上面三条指令将`10000H(1000:0)`中的数据读到`al`中. 

已知的mov指令可完成的两种传送功能：
（1）将数据直接送入寄存器;
（2）将一个寄存器中的内容送入另一个寄存器中.

**除此之外, mov 指令还可以将一个内存单元中的内容送入一个寄存器.**

mov指令的格式：
      **mov 寄存器名, 内存单元地址**

“[…]”表示一个内存单元,  “[…]”中的0表示**内存单元的偏移地址**.

**执行指令时, 8086CPU自动取`DS中的数据`为内存单元的`段地址`.**

如何用mov指令从10000H中读取数据？
10000H表示为1000:0(段地址:偏移地址)
将段地址1000H放入ds
用mov al,[0]完成传送. (mov指令中的[]说明操作对象是一个内存单元, []中的0说明这个内存单元的偏移地址是0, 它的段地址默认放在ds中) 指令执行时, 8086CPU自动从DS中取出.

```asm
mov bx,1000H
mov ds,bx
```
**如何把1000H送入ds？**

8086CPU不支持将数据直接送入段寄存器的操作, ds是一个段寄存器.(硬件设计的问题)

mov ds,1000H 是非法的. 只好用一个寄存器作为中转.

**数据→通用寄存器→DS段寄存器**

> 前面的CS寄存器是用jmp改的.

## 字的传送

上面mov指令在寄存器与内存之间进行**字节型**数据的传送.  8086CPU是16位结构, 有16根数据线, 所以可一次性传16位数据, 即一个字. **只需要在mov指令中给出16位寄存器名就行**.

```asm
mov bx,1000H
mov ds,bx
mov ax,[0]  ;1000:0字节型数据传到ax
mov [0],cx
```

![1671701070457](Asm_lang.assets/1671701070457.png)

> 上面的每一步执行结果依次是: ax=1000H, ds=1000H, ax=1123H,bx=6622H,cx=2211H,bx=6622H+2211H=8833H, cx=2211H+6622H=8833H

**如果目标寄存器是8位, 就取8位, 目标寄存器是16位就到内存取16位. 高地址高字节, 低地址低字节.**

问题3.4 看图3.3, 指令执行完内存中的值是多少.

![1671701562684](Asm_lang.assets/1671701562684.png)

> ax=1000H, ds=1000H, ax=2C34H, [0]=34H, [1]=2CH, bx=2C34H, bx=2C34-1122H=1B23H, 
>
> [2]=23H, [3]= 1BH.

## mov,add,sub指令

**已学mov指令的几种形式：**

​	mov 寄存器, 数据
​	mov 寄存器, 寄存器
​	mov 寄存器, 内存单元
​	mov 内存单元, 寄存器
​	mov 段寄存器,寄存器

**由此推到正确的命令:**

​	mov 寄存器,段寄存器
​	mov 内存单元,寄存器
​	mov 内存单元,段寄存器
​	mov 段寄存器,内存单元

> mov 内存单元, 数据 跟 mov 内存单元, 内存单元 是错的
>
> 同时注意`CS`跟`IP`这两个特殊的寄存器.

**add与sub有以下几种:**

​	add/sub 寄存器,数据
​	add/sub 寄存器,寄存器
​	add/sub 寄存器,内存单元
​	add/sub 内存单元,寄存器

**错误的:**

​	add/sub 段寄存器,寄存器, 
​	add/sub 内存单元, 内存单元,
​	add/sub 内存单元, 数据

## 数据段Data Segment

前面讲过, 对于8086PC机, 我们可以根据需要将一组内存单元定义为一个段(可以是代码段, 数据段等). 

我们可以将一组长度为N(N≤64K), 地址连续, 起始地址为16的倍数的内存单元**当作专门存储数据**的内存空间, 从而定义了一个**数据段.** 

那数据段肯定离不开DS寄存器的使用了.

> 不管是现在的数据段, 还是之前的指令段. 寻址方式都是一样的, `段地址x16 + 偏移量`.
> 只不过CS寄存器的偏移量是IP中的内容罢了, 而DS的偏移量是具体的数字[n].

## 3.1节\~3.5节 小结

1. 字在内存中存储时, 要用**两个地址连续的内存单元**来存放, 字的**低位字节存放在低地址单元**中, **高位字节存放在高地址单元**中.
2. **用 mov 指令要访问内存单元**, 可以在mov指令中只给出单元的偏移地址, 此时, **段地址默认在DS寄存器中**.
3. [address]**表示一个偏移地址为address的内存单元**.
4. 在**内存和寄存器之间传送字型数据**时, **高地址**单元和**高8位寄存器**, **低地址**单元和**低8位寄存器**相对应.
5. mov, add, sub是具有两个操作对象的指令. **jmp**是具有一个操作对象的指令.
6. 可以根据自己的推测, 在Debug中实验指令的新格式.

> 数据与指令在内存中无区别, CS:IP指向的就是作指令解释, 进行其它运算移位等操作, 由DS:[n]指向的是数据.

## 栈

它是一种数据结构, 特点是: 先进后出, 后进先出.

栈只有两个操作, 入栈和出栈, 都是从栈顶进行操作.

> 入栈: 将新元素放入栈顶, 出栈: 从栈顶取出一个元素.

## CPU提供的栈机制

现代的CPU包括8086都有栈的设计, 8086提供了相关的指令来以**栈**的方式**访问内存空间**. 也就是说, 8086CPU, 可以将**一段内存**当做栈来用.

8086提供入栈和出栈的指令, 最基本的两个是PUSH(入栈)和POP(出栈). 

**push ax**: 将寄存器ax中的数据送入栈中;
**pop ax**: 从栈顶取出数据送入ax. 

8086CPU的入栈和出栈操作都是**`以字为单位`**进行的. 

![1671779690047](Asm_lang.assets/1671779690047.png)
```asm
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```

注意: 字型数据用两个单元存放, 高地址单元放高 8 位, 低地址单元放低8 位.

1, CPU如何知道一段内存空间被当作栈使用？
2, 执行push和pop的时候, 如何知道哪个单元是栈顶单元？

结论：8086CPU中, 任意时刻, **`SS:SP` 指向栈顶元素.**

> 类似CS:IP指向指令地址.
>
> 8086CPU中, 有两个寄存器:
> 段寄存器SS  存放栈顶的段地址
> 寄存器SP      存放栈顶的偏移地址

因为**按字操作**, 所以`sp` 就是+-2, **出栈后+2, 入栈前-2**

![1671780106591](Asm_lang.assets/1671780106591.png)

将10000H\~1000FH 这段空间当作栈段, SS=1000H, 栈空间大小为16 字节, 栈最底部的字单元地址为1000:000E.

任意时刻, SS:SP指向栈顶, 当栈中只有一个元素的时候, SS = 1000H, SP=000EH.

栈为空, 就相当于栈中唯一的元素出栈, 出栈后, SP=SP+2, SP 原来为 000EH, 加 2 后SP=10H.
所以, **当栈为空的时候, SS=1000H, SP=10H.**

![1671790499278](Asm_lang.assets/1671790499278.png)

> 注意POP之后, 1000CH出的2266H**依然存在**, **但它已经不在栈内了**, 因为栈顶是1000EH. 所以再执行push时2266H就会被覆盖.

## 栈顶超界的问题

SS和SP只记录了栈顶的地址, 依靠SS和SP可以保证在入栈和出栈时找到栈顶.
可是, 如何能够保证在入栈, 出栈时, 栈顶不会超出栈空间?

![1671798299913](Asm_lang.assets/1671798299913.png)

![1671798353077](Asm_lang.assets/1671798353077.png)

上面两个图, 分别展示PUSH和POP操作导致超界.

> 栈满执行push, 栈空执行pop. 都会导致栈顶超界的问题, 后续操作就会踩踏别的内存空间.

**栈顶超界非常的危险**, 因为栈外空间很有可能就放着别的用途的数据或者代码. 一旦这些数据被误改, 可能导致非常可怕的后果.

8086CPU的工作机理, 只考虑当前的情况:
当前栈顶在何处;
当前要执行的指令是哪一条.

所以8086CPU**不能保证**我们对栈的操做不会越界. 它只知道栈顶在哪(SS:SP), 不知道栈空间我们安排了多大.

**所以, 程序员在写汇编的时候, 用到栈的时候, 一定要考虑超界越界的问题.** 

根据可能用到的最大栈空间, 安排栈的大小, 防止入栈的数据太多, 导致越界. 执行出栈也要注意, 防止栈空了还在出栈.

## push,pop指令

push和pop指令是可以在**寄存器和内存**之间传送数据的.

指令格式:

```asm
push 寄存器  ;把寄存器里的数据入内存栈
pop  寄存器  ;把栈顶的数据放到寄存器中
```

拓展:
```asm
push 段寄存器  ;把段寄存器里的数据入内存栈
pop  段寄存器  ;把栈顶的数据放到段寄存器中
```
> 注意CS这个段寄存器的特殊性
```asm
内存单元之间传送数据:
push 内存单元  ;将一个内存字单元处的字入栈.(前面提到过 栈的操作以字为单位)
pop  内存单元  ;出栈, 用一个内存字单元接收出栈的数据
```

如:

```asm
mov ax,1000H
mov ds,ax    ;内存数据段地址放入ds
push [0]     ;将1000:0放入 ss:sp指向的栈中
pop  [2]     ;把栈中数据 送入1000:2处
```

push pop指令只给出内存单元的偏移地址, 段地址从ds中取.

> `ds` 放数据段 段地址 , `[n]`给出偏移地址  → `ds:[n]`
> `cs `放指令段(代码段) 段地址,` ip`给出偏移地址  → `cs:ip`
> `ss` 放栈 段地址, `sp`栈指针给出栈顶偏移地址. → `ss:sp`

**sp 可以用mov 放入立即数 就是`mov sp,1000H**`

问题3.7 :

```asm
mov cx,1000H ;我觉得教材写的不对,题目意思肯定是ax已经有数据了
mov ss,cx
mov sp,0010H ;空栈, 入栈会先SP=SP-2
push ax
push bx
push ds
```

问题3.8:

```asm
mov ax,001AH
mov bx,001BH
mov cx,1000H
mov ss,cx
mov sp,0010H
push ax
push bx
sub ax,ax  ;可用mov ax,0 但它是3个字节, 而sub是两个字节
sub bx,bx   
pop bx    ;后进先出原则
pop ax
```

问题3.9的点在于:

执行push时：
先改变SP, 后向SS:SP处传送.
执行pop时：
先读取SS:SP处的数据, 后改变SP.

push, pop 等栈操作指令, 修改的只是SP. 也就是说, 栈顶的变化范围最大为: 0~FFFFH.
提供: SS, SP指示栈顶; 改变SP后写内存的入栈指令; 读内存后改变SP的出栈指令.

## 栈的小结

1. 8086CPU提供了栈操作机制, 方案如下:
   在SS, SP中存放栈顶的段地址和偏移地址;
   提供入栈和出栈指令, 他们根据SS:SP指示的地址, 按照栈的方式访问内存单元.
2. push指令的执行步骤：
   1)SP=SP-2;
   2)向SS:SP指向的字单元中送入数据.
3. pop指令的执行步骤:
   1)从SS:SP指向的字单元中读取数据;
   2)SP=SP+2.
4. 任意时刻, SS:SP指向栈顶元素. .
5. 8086CPU只记录栈顶, 栈空间的大小我们要自己管理. 
6. 用栈来暂存以后需要恢复的寄存器的内容时, 寄存器出栈的顺序要和入栈的顺序相反. 
7. push, pop**实质上是一种内存传送指令**, 注意它们的灵活应用.

**栈是一种非常重要的机制, 一定要深入理解, 灵活掌握.**

## 栈段

段的概念里讲过, 对于8086PC机, 在编程时, 我们可以根据需要, 将一组内存单元定义为一个段.
我们可以将长度为 N(N ≤ 64K) 的一组地址连续, 起始地址为16的倍数的内存单元, 当作栈空间来用, 从而定义了一个**栈段**.

比如我们将10010H\~1001FH 这段长度为16字节的内存空间当作栈来用, 以栈的方式进行访问.
这段空间就可以成为栈段, 段地址为1001H, 大小为16字节.

将一段内存当作栈段, **仅仅是我们在编程时的一种安排**, CPU 并不会由于这种安排, 就在执行push, pop等栈操作指令时就自动地将我们定义的栈段当作栈空间来访问.

## 段的总结

我们可以将一段内存定义为一个段, 用一个段地址指示段, 用偏移地址访问段内的单元. 这完全是我们自己的安排. 

我们可以用一个段存放数据, 将它定义为“数据段”；
我们可以用一个段存放代码, 将它定义为“代码段”；
我们可以用一个段当作栈, 将它定义为“栈段”；

对于数据段, 将它的段地址放在 DS中, 用mov, add, sub等访问内存单元的指令时, CPU就将我们定义的数据段中的内容当作数据段来访问；

对于代码段, 将它的段地址放在 CS中, 将段中第一条指令的偏移地址放在IP中, 这样CPU就将执行我们定义的代码段中的指令；

对于栈段, 将它的段地址放在SS中, 将栈顶单元的偏移地置放在 SP 中, 这样CPU在需要进行栈操作的时候, 比如执行 push, pop 指令等, 就将我们定义的栈段当作栈空间来用. 

可见, 不管我们如何安排 , CPU 将内存中的某段内存当作代码 , 是因为CS:IP指向了那里；CPU将某段内存当作栈 , 是因为 SS:IP 指向了那里. 

可见, 不管我们如何安排 , CPU 将内存中的某段内存当作代码 , 是因为CS:IP指向了那里；CPU将某段内存当作栈 , 是因为 SS:IP 指向了那里. 我们一定要清楚 , 什么是我们的安排, 以及如何让CPU按我们的安排行事. 要非常的清楚CPU的工作机理, 才能在控制CPU来按照我们的安排运行的时候做到游刃有余. 

比如我们将10000H~1001FH安排为代码段, 并在里面存储如下代码：

```asm
 mov ax,1000H
 mov ss,ax
 mov sp,0020H  ;初始化栈顶
 mov ax,cs
 mov ds,ax     ;设置数据段段地址
 mov ax,[0]
 add ax,[2]
 mov bx,[4]
 add bx,[6]
 push ax
 push bx
 pop ax
 pop bx
```

设置CS=1000H, IP=0, 这段代码将得到执行. 可以看到, 在这段代码中, 我们又将10000\~1001FH 安排为栈段和数据段. 10000H\~1001FH这段内存, 既是代码段, 又是栈段和数据段. 

一段内存, 可以既是代码的存储空间, 又是数据的存储空间, 还可以是栈空间, 也可以什么也不是. 关键在于CPU中寄存器的设置, 即：CS:IP, SS:SP, DS的指向. 

# 第4章 第一个程序

编写程序→编译链接→执行

## 一个源程序从写出到执行

![1671863200996](Asm_lang.assets/1671863200996.png)

1. 编写源程序

   使用文本编辑器(如记事本, Nodepad++, UltraEdit等), 用汇编语言编写汇编源程序.

2. 对源程序进行编译连接

   使用汇编语言编译程序(MASM.EXE)对源程序文件中的源程序进行编译, 产生目标文件; 再用连接程(LINK.EXE)对目标文件进行连接, 生成可在操作系统中直接运行的可执行文件.

   可执行文件中包含两部分内容:

   - **程序** (从原程序中的汇编指令翻译过来的机器码)和**数据**(源程序中定义的数据)
   - **相关的描述信息** (比如:程序有多大, 要占多少内存空间等)

   > 这一步产生一个 可在操作系统中运行的`可执行文件`.

3. 执行可执行文件中的程序

   在操作系统中, 执行可执行文件中的程序.
   操作系统依照可执行文件中的描述信息, 将可执行文件中的机器码和数据加载入内存, 并进行相关的初始化(比如: 设置CS:IP指向第一条要执行的指令), 然后由CPU执行程序.

## 源程序

程序4.1

```asm
assume cs:codesg
codesg segment
	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	mov ax,4c00H
	int 21H
codesg ends
end
```

### 1.伪指令

汇编语言源程序中, 有两种指令, 汇编指令与伪指令.

**汇编指令**有**对应的机器码的指令**, **可以被编译为机器指令**, **最终为CPU所执行**.

**伪指令**没有对应的机器码的指令, 最终**不被CPU所执行**. 伪指令是**由编译器来执行的指令**, **编译器根据伪指令来进行相关的编译工作**. 

程序4.1中的三种伪指令:

- XXX segment

  .......

  XXX ends　

  segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，ends 说明一个段结束。一个段必须有一个名称来标识，使用格式为：
              段名 segment
              段名 ends

  一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。

  一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

- end

  end 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译. 如果程序写完了，要在结尾处加上伪指令end 。否则，编译器在编译程序时，无法知道程序在何处结束。

  切记：不要搞混了end和ends。ends与segment合用, 结束一个段. end结束整个程序.

- assume

  含义为“假设”. 它假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联。

  通过assume说明这种关联，在需要的情况下 ，编译程序可以将段寄存器和某一个具体的段相联系。

  assume不是一条需要深入理解的伪指令, 以后编程时, 记得用它将有特定用途的段跟相关的段寄存器关联起来即可.

  > 如程序4.1 `assume cs:codesg` 把接下来的`codesg`段 与CS段寄存器联系起来.

### 2.源程序中的"程序"

汇编源程序：
              伪指令    (编译器处理)
              汇编指令 (编译为机器码)
程序: 源程序中最终由计算机执行, 处理的指令或数据.

我们可以将源程序文件中的所有内容称为源程序, 将源程序中最终由计算机执行处理的指令或数据, 称为程序。
程序最先以汇编指令的形式存在源程序中, 经编译, 连接后转变为机器码, 存储在可执行文件中。

![1671874569701](Asm_lang.assets/1671874569701.png)

### 3.标号

一个标号指代了一个地址。
如, codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

### 4.程序的结构

前面在debug中写了一些简短的汇编指令, 但大一点的程序就不行.

必须要写出能让编译器进行编译的源程序, 这样的源程序应该具备起码的结构.

源程序是由一些段构成的. 可以在这些段中存放代码, 数据, 或将某个段当作栈空间. 

任务: 编程算2^3. 源程序怎么写?

- 定义一个段, 名abc

  abc segment

  ...

  abc ends

- 在这个段中写入汇编指令, 实现任务.

  ```asm
  abc segment
  	mov ax,2
  	add ax,ax
  	add ax,ax
  abc ends
  ```

- 指出程序结束之处

  ```asm
  abc segment
  	mov ax,2
  	add ax,ax
  	add ax,ax
  abc ends
  end   ;结束
  ```

- abc被当做代码段来用, 所以, 把abc与cs联系起来.(非必须)

  ```asm
  assume cs:abc  ;关联cs与abc
  abc segment
  	mov ax,2
  	add ax,ax
  	add ax,ax
  abc ends
  end   ;结束
  ```

> 定义一个段
> 实现处理任务
> 程序结束
> 段与段寄存器关联
> 程序返回

程序示例:

```asm
assume cs:code,ds:data,ss:stack
data segment
dw 0123H,0456H,0789H,0abcH,0defH
data ends
stack segment
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
mov ax,stack
mov ss,ax
mov sp,20h ;设置栈段
mov ax,data
mov ds,ax ;设置数据段
mov bx,0
mov cx,8
s: push [bx]
add bx,2
loop s
....
code ends
end
```



### 5.程序返回

我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢？

P2程序在可执行文件中, 则必须有一个正在运行的P1程序, 把P2从可执行文件加载到内存中, 将CPU控制权交给P2, 那P2才行运行. P2运行后, P1暂停运行.

P2运行完, 应将CPU控制权交还给P1, 然后p1继续运行.

一个程序结束后，将CPU的控制权交还给**使它得以运行的程序**，我们称这个过程为：**程序返回**。

如何返回?

程序4.1 最后有两条指令:

```asm
mov ax,4C00H
int 21H
```

这两条指令, 就是返回.

![1671876491005](Asm_lang.assets/1671876491005.png)

### 6.语法错误和逻辑错误

一般来说, 程序在编译期间, 别编译器发现的错误是语法错误.

逻辑错误是程序在编译时不能表现出来的、在运行时发生的错误；不容易发现。

```asm
assume cs:abc  ;关联cs与abc
abc segment
	mov ax,2
	add ax,ax
	add ax,ax
	
	mov ax,4C00H  ;程序返回
	int 21H
abc ends
end   ;结束
```

## 编辑源程序

这个能写出来就行.

![1671879489905](Asm_lang.assets/1671879489905.png)

![1671879508364](Asm_lang.assets/1671879508364.png)

写完保存就行了.

## 编译

编译器用masm.

![1671879571153](Asm_lang.assets/1671879571153.png)

编译完

![1671879615990](Asm_lang.assets/1671879615990.png)

会有这几个文件. source listing文件 跟 交叉引用文件可以不生成.

> source filename源文件名, 缺省是.asm格式, 如果你是写在txt格式中, 那就要输入test.txt
>
> 跟masm同路径, 则路径可以不写, 不同路径, 则要把路径补全, 比如D:\code\test.asm

![1671880179349](Asm_lang.assets/1671880179349.png)

## 连接

上一步编译完, 得到个obj目标文件. 现在用它来连接

![1671880575650](Asm_lang.assets/1671880575650.png)

用微软的overlay linker3.6 连接器.

跟link.exe同路径, 则路径可以不写, 不同路径, 则要把路径补全, 比如D:\code\test.obj. 

> map映像文件, lib库文件(库文件里包含一些可调用的函数, 若程序在调用了某个库的函数, 就必须把这个库文件和目标文件连接. 生成可执行文件) 这里没有调用, 这一步也跳过.

警告是没有栈的段, 我们没用到栈可以忽略警告.

![1671881279791](Asm_lang.assets/1671881279791.png)

连接的作用有以下几个：

1. 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；
2. 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；

3. 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这此内容处理为最终的可执行信息。
   所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

> 这里再次强调一下，我们学习汇编的主要目的，就是通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到可以随心所欲地控制计算机的目的。基于这种考虑, 我们的编程活动, 大都是直接对硬件进行的. 我们用汇编语言编程，就要用到 ：编辑器（Edit）、编译器（masm）、连接器（link）、调试工具（debug）等所有工具，而这些工具都是在操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中进行。
>
> 涉及到的操作系统跟编译原理等学科的知识和原理, 不细说.

## 简化编译和连接

![1671881813584](Asm_lang.assets/1671881813584.png)

中间文件全部会忽略.

路径的问题跟上面一样.

## 执行

![1671881932021](Asm_lang.assets/1671881932021.png)

因为没有写指令向显示器输出信息, 只是做了送数据到寄存器和加法, 没有输出.

## 谁加载了程序并运行?

在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2，将 P1 从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行；
当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P2。

**操作系统的外壳**

操作系统是由多个功能模块组成的庞大 、复杂的软件系统。任何通用的操作系统 ，都要提供一个称为shell（外壳）的程序 ，用户（操作人员）使用这个程序来操作计算机系统工作。

DOS中有一个程序command.com ，这个程序在 DOS 中称为命令解释器，也就是DOS系统的shell。

![1671883780665](Asm_lang.assets/1671883780665.png)

![1671883863147](Asm_lang.assets/1671883863147.png)

## 程序执行过程的跟踪

为了观察程序的运行过程 ，我们可以使用Debug。
Debug 可以将程序加载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU 的控制，这样，我们就可以使用Debug 的相关命令来单步执行程序 ，查看每条指令指令的执行结果。

接下来可以用R命令看一下各个寄存器的设置情况：
![1671884208063](Asm_lang.assets/1671884208063.png)
可以看到，Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe 中程序的机器码共有15个字节。

现在程序已从 1.exe 中装入内存，接下来我们查看一下它的内容，可是我们查看那里的内容呢？
程序被装入内存的什么地方？
我们如何得知？
在DOS系统中.EXE文件中的程序的加载过程如下:

![1671884274818](Asm_lang.assets/1671884274818.png)

> 注意：有一步称为重定位的工作我们在上面没有讲解，因为这个问题和操作系统的关系较大，我们不作讨论。

- 程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0；
- 这个内存区的前256 个字节中存放的是PSP，dos用来和程序进行通信。从 256字节处向后的空间存放的是程序。

所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为 0，则物理地址为SA×16+0。

因为PSP占256（100H）字节，所以程序的物理地址是：
SA×16+0+256= SA×16+16×16=（SA+16）×16+0
可用段地址和偏移地址表示为：`SA+10H:0`

> 看一下上上个图: DS=129E 那PSP就是129E:0, CS:IP = 12AE:0(129EH+10H)

U命令看一下指令:

![1671885025709](Asm_lang.assets/1671885025709.png)

用T命令担不执行程序中的每一条指令，并观察每条指令的执行结果, 到了 int 21，我们要用`P命令`执行:

![1671885093205](Asm_lang.assets/1671885093205.png)

int 21 执行后，显示“Program terminated normally”，返回到Debug中。注意，要使用P命令执行int 21。

> 需要注意的是，在 DOS 中运行程序时，是command将程序加载入内存；所以程序运行结束后返回到command中，而在这里是debug 将程序加载入内存，所以程序运行结束后要返回到Debug中。

使用Q命令退出Debug，将返回到command中，因为Debug是由command加载运行的。

我们在 DOS中用 “Debug 1.exe” 运行Debug对1.exe进行跟踪时，程序加载的顺序是：command加载Debug，Debug加载1.exe。

返回的顺序是：从1.exe中的程序返回到Debug，从Debug返回到command。

# 第5章 [BX]与loop指令

## [bx]与内存单元的描述

[bx]是什么呢？和[0]有些类似，[0]表示内存单元，它的偏移地址是0。
mov ax, [0] 将内存单元ds:0的内容送入ax, 长度2个字节.
mov al, [0]  将内存单元ds:0的内容送入al, 长度1个字节.

要完整地描述一个内存单元，需要两种信息：
（1）内存单元的地址；
（2）内存单元的长度（类型）。

用[0]表示一个内存单元时，0 表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出,如前边的AX,AL。

[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令：

mov ax,[bx] 将内存单元ds:[bx]的内容送入ax, 长度2个字节. 

不同的是[0], 偏移地址就是0, 是立即寻址, 而[bx]的偏移地址在bx中. 有点类似组成原理讲的 `寄存器间接寻址`.

mov al,[bx] 将内存单元ds:[bx]的内容送入ax, 长度1个字节.

## loop

英文单词“loop”有循环的含义，显然这个指令和循环有关。

## 本书定义的描述性符号"()"

为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号"()"来表示一个寄存器或一个内存单元中的内容。 

如(ax)就表示ax中的内容, (al)表示al中的内容. (20000H) 表示内存20000H地址中的内容.

"()"中的元素可以有三类: `寄存器名`, `段寄存器名`, `内存单元物理地址`(一个20位数据)

(ax) (ds) (al) (20000H) ((ds)\*16+(bx))等是对的.

(2000:0) ((ds):1000H)等是错的

我们看一下(X)的应用，比如：
（1）ax中的内容为`0010H`，我们可以这样来描述：`(ax)=0010H`； 
（2）`2000:1000` 处的内容为`0010H`，我们可以这样来描述：`(21000H)=0010H`；
（3）对于`mov ax,[2]`的功能，我们可以这样来描述：`(ax)=((ds)*16+2)`；
（4）对于`mov [2],ax` 的功能，我们可以这样来描述：`((ds)*16+2)=(ax)`； 
（5）对于 `add ax,2` 的功能，我们可以这样来描述：`(ax)=(ax)+2`； 
（6）对于`add ax,bx`的功能，我们可以这样来描述：`(ax)=(ax)+(bx)`；
（7）对于`push ax`的功能，我们可以这样来描述：
	 `(sp) = (sp)-2 `
         `((ss)*16＋(sp))=(ax)`
（8）对于`pop ax `的功能，我们可以这样来描述：
  	`(ax)=((ss)*16+(sp))`
 	 `(sp)=(sp)+2`

"(x)"所表示的数据有两种类型: 字节和字. 是哪种类型由寄存器名或具体运算决定.

如, (al)得到数据为字节型. (ds)(ax)等得到的是字.

(al)=(20000H)则(20000H)得到数据为`字节型`.  换成(ax) 就是字型

## 约定符号idata表示常量

我们在Debug 中写过类似的指令：`mov ax,[0]`，表示将` ds:0 `处的数据送入ax中。指令中，在“[…]”里用一个常量0表示内存单元的偏移地址。以后，我们用idata表示常量, 例如:

`mov ax,[idata`]就代表`mov ax,[1]`、`mov ax,[2]`、`mov ax,[3]`等。

`mov bx,idata`就代表`mov bx,1`、`mov bx,2`、`mov bx,3`等。

`mov ds,idata`就代表`mov ds,1`、`mov ds,2`等，它们都是非法指令。

## 5.1 [BX]

`mov ax,[bx] `功能：bx 中存放的数据作为一个偏移地址EA ，段地址SA 默认在ds 中，将SA:EA处的数据送入ax中。 即：` (ax)=((ds)*16 +(bx))；`

`mov [bx],ax` 功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。 即：`((ds)*16 +(bx)) = (ax)`

## 5.2 Loop指令

loop的指令格式为: `loop 标号`, CPU执行loop指令的时候, 要进行两步操作, 

① (cx)=(cx)-1; 
② 判断cx中的值, 不为零则转至标号处执行程序, 如果为零则向下执行.

从上面的描述中，我们可以看到，cx中的值影响着loop指令的执行结果。通常（注意，我们说的是通常）我们用loop指令来实现循环功能，cx 中存放循环次数。

这里我们讲解loop指令的功能，关于loop指令如何实现转至标号处的细节，将在后面的课程中讲解。下面我们通过一个程序来看一下loop指令的具体应用: 

```asm
assume cs:code
  code segment
     mov ax,2
     mov cx,11 ;给定循环次数  
  s: add ax,ax ; s就是标号, 它实际上标识了个地址,这个地址处有条指令add ax,ax
     loop s    ; 执行loop会先(cx)=(cx)-1,判断cx中的值不为零则转至标号处执行程序

	  mov ax,4c00h
	  int 21h
 code ends
 end
```

从上边的课程中，我们可以总结出用cx和loop 指令相配合实现循环功能的三个要点：
（1）在cx中存放循环次数；
（2）loop 指令中的标号所标识地址要在前面；
（3）要循环执行的程序段，要写在标号和loop 指令的中间。

用cx和loop指令相配合实现循环功能的程序框架如下：
   mov cx,循环次数
s:循环执行的程序段
   loop s 

## 5.3 在Debug中跟踪用loop指令实现的循环程序

考虑这样一个问题，计算ffff:0006单元中的数乘以3，结果存储在dx中。我们分析一下：
（1）运算后的结果是否会超出dx所能存储的范围？
   ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间，则用它和3相乘结果不会大于65535，可以在dx 中存放下。

（2）我们用循环累加来实现乘法，用哪个寄存器进行累加？我们将ffff:0006单元中的数赋值给ax，用dx进行累加。先设(dx)=0，然后做3次(dx)=(dx)+(ax)。
（3） ffff:0006单元是一个字节单元，ax是一个 16 位寄存器，数据长度不一样，如何赋值？

注意, 我们说的是“赋值”，就是说，让 ax 中的数据的值（数据的大小）和ffff:0006 单元中的数据的值（数据的大小）相等。8 位数据01H和16位数据0001H的数据长度不一样，但它们的值是相等的。	

那么我们如何赋值？
ffff:0006单元中的数据是XXH，若要ax中的值和ffff:0006单元中的相等，ax中的数据应为00XXH。所以，若实现ffff:0006单元向ax 赋值，我们应该令(ah)=0，(al)=(ffff6H)。

程序就如下:

```asm
assume cs:code
code segment
	mov ax,0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0
	mov ds,ax
	mov bx,6
	mov ah,0
	mov al,[bx]
	mov dx,0
	mov cx,3
s: add dx,ax
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```

![1672314997448](Asm_lang.assets/1672314997448.png)

下面，我们将前面的程序改一下，计算 ffff:0006单元中的数乘以 123，结果存储在dx中。
更改程序：只要将寻循环次数改为123。

若不想在debug中一步步追踪, 那就直接用g命令. `g 0012`命令 表示执行程序到当前代码段的0012h处.

debug就会从当前CS:IP指向的指令执行, 一直到(IP)=0012h为止.

![1672315486996](Asm_lang.assets/1672315486996.png)

100多次的循环执行, 不能用t命令, 用`p 命令` 执行循环体.

![1672315553289](Asm_lang.assets/1672315553289.png)

也可以用g 命令 直接到循环体后面的指令.

![1672315646095](Asm_lang.assets/1672315646095.png)

就是当前CS:IP是循环体, 下面一条指令就是loop s, 0016就是loop s 后面一条.所以 g 0016, 就是直接执行到0016.

循环会被执行完

## 5.4 debug和汇编编译器masm对指令的不同处理

在Debug中写过类似的指令：
            mov ax,[0] 
表示将ds:0处的数据送入al中。

但是在汇编元程序中，指令“mov ax,[0]”被编译器当作指令“mov ax,0”处理。

![1672317263841](Asm_lang.assets/1672317263841.png)

![1672317294602](Asm_lang.assets/1672317294602.png)

总结一下就是, debug认为[idata]是一个内存单元, idata是内存单元的偏移地址; 而编译器将[idata]解释为idata数据.

源程序中访问内存单元, 就可以把偏移地址送入bx寄存器中, 用[bx]的方式来访问内存单元. 比如:

```asm
mov ax,2000h
mov ds,ax
mov bx,0
mov al,[bx]
```

那在源文件中, 如果不想用bx间接给出内存单元偏移地址, 那就给出完整的地址:

```asm
mov ax,2000h
mov ds,ax
mov ax,ds:[0]
```

给出ds:[n] 这个完整地址就行了.

mov al, [0]  这个是把0赋值给al
mov al, ds:[0]  这个是把DSx16+0地址单元中的内容赋值给al
mov al, [bx]   dsx16+bx地址单元中内容赋值给al
mov al, ds:[bx]   跟上面这个一样

从这个比较可以看出:

1. 在汇编源程序中, 如果用指令访问一个内存单元, 则在指令中必须用"[...]"来表示内存单元, 如果在"[]"里用一个常量idata直接给出内存单元的偏移地址,就要在"[]"前面加上段前缀
2. 若在"[]"里用寄存器, 比如bx间接给出内存单元的偏移地址, 则段地址默认在ds中. 也可以显示给出.

## 5.5 loop和[bx]的联合应用

问题：计算ffff:0~ffff:b字节单元中的数据的和，结果存储在dx中.

分析：
（1）运算后的结果是否会超出 dx 所能存储的范围？
ffff:0～ffff:b内存单元中的数据是字节型数据，范围在0～255之间，12个
这样的数据相加，结果不会大于 65535，可以在dx中存放下。
（2）是否可以将 ffff:0～ffff:b中的数据直接累加到dx中？
add dx, ds:[addr] ;(dx)=(dx)+?
期望：取出内存中的8位数据进行相加
实际：取出的是内存中的16位数据
（3）是否可以将 ffff:0～ffff:b中的数据直接累加到dl中？
add dl, ds:[addr] ;(dl)=(dl)+?
期望：取出内存中的8位数据相加
实际：取出的是内存中的8位数据，但很有可能造成进位丢失。

对策：取出8位数据，加到16位的寄存器
mov al, ds:[addr]
mov ah, 0
add dx, ax

用一个16位寄存器来做中介。将内存单元中的 8 位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。

问题5.4:

```asm
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov bx,0
	mov dx,0
	mov cx,12
s:  mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx
	loop s
	
	mov ax,4c00h
	int 21h
code ends
end
```

## 5.6段前缀

指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。
我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。

这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:”、“cs:”、“ss:”或“es:”，在汇编语言中称为**段前缀**。

## 5.7 一段安全的空间

在8086模式中，随意向一段内存空间写入内容是很危险的 ，因为这段空间中可能存放着重要的系统数据或代码。
比如下面的指令：
           mov ax,1000h
           mov ds,ax
           mov al,0
           mov ds:[0],al

我们以前在Debug中，为了讲解上的方便，写过类似的指令。
但这种做法是不合理的 ，因为之前我们并没有论证过 1000:0中是否存放着重要的系统数据或代码。
如果1000:0中存放着重要的系统数据或代码，“mov ds:[0],al”  将其改写，将引发错误。

可见，我们在不能确定一段内存空间中是否存放着重要的放据或代码的时候，不能随意向其中写入内容。

不要忘记，我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。

注意：我们在纯DOS方式（实模式）下，可以不理会DOS，直接用汇编语言去操作真实的硬件，因为运行在CPU实模式下的DOS，没有能力对硬件系统进行全面、严格地管理。

但在Windows XP\2000、UNIX这些运行于CPU保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。   硬件已被这些操作系统利用CPU保护模式所提供的功能全面而严格地管理了。 

在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200~0:2FF（ 0:200h~0:2FFh）的256 个字节的空间。所以，我们使用这段空间是安全的。

## 5.8 段前缀的使用

考虑一个问题：
将内存ffff:0~ffff:b段元中的数据拷贝到 0:200~0:20b单元中。

```asm
程序5.8                            程序5.9
assume cs:code                     assume cs:code
code segment                       code segment
	mov bx,0                          mov ax,0ffffh
	mov cx,12                         mov ds,ax
s:	mov ax,0ffffh                     mov ax,0020h
	mov ds,ax                         mov es,ax
	mov dl,[bx]                       mov bx,0
	mov ax,0020h                      mov cx,12
	mov ds,ax                      s: mov dl,[bx]
	mov [bx],dl                       mov es:[bx],dl
	inc bx                            inc bx
	loop s                            loop s

mov ax,4c00h                        mov ax,4c00h 
int 21h                             int 21h
code ends                           code ends
end                                 end
```

改进的程序中，使用 es 存放目标空间0020:0\~0020:b的段地址，用ds存放源空间ffff:0\~ffff:b的段地址。
在访问内存单元的指令“mov es:[bx],al”中 ，显式地用段前缀 “es:” 给出单元的段地址，这样就不必在循环中重复设置ds。

## 实验4

```asm
一二问一块写:
assume cs:code
code segment
    mov ax,0020h
    mov ds,ax
    mov ax,0
    mov cx,64
s:  mov [ax],al
    inc ax
    loop s
    mov ax,4c00h
    int 21h
code ends
end
```

```assembly
第三问
assume cs:code
code segment
    mov ax,cs
    mov ds,ax
    mov ax,0020h
    mov es,ax
    mov bx,0
    mov cx,23       ;23个字节(0~22)
s:  mov al,[bx]
    mov es:[bx],al
    inc bx
    loop s
    mov ax,4c00h
    int 21h
code ends
end
```

# 第6章 包含多个段的程序

## 6.1 在代码段中使用数据

考虑这样一个问题，编程计算以下8个数据的和，结果存在ax 寄存器中：
   0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H。

在前面的课程中，我们都是累加某些内存单元中的数据，并不关心数据本身。可现在我们要累加的就是已经给定了数值的数据。 

```assembly
assume cs:codesg
codesg segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
  	mov bx,0
	mov ax,0
	mov cx,8
 s: add ax,cs:[bx]
	add bx,2
	loop s
	mov ax,4c00h
	int 21h
codesg ends
end
```

程序第一行中的 “dw”的含义是定义字型数据。dw即define word。在这里，我们使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节。

> dw 定义一个字
> db 定义一个字节
> dd 定义一个双字

程序中的指令就要对这8个数据进行累加，可这8个数据在哪里呢？
由于它们在代码段中，程序在运行的时候CS中存放代码段的段地址，所以我们可以从CS中得到它们的段地址。

这8个数据的偏移地址是多少呢？
因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8 个数据就在代码段的偏移0、2、4、6、8、A、C、E处。
程序运行时，它们的地址就是CS:0、CS:2、CS:4、CS:6、CS:8、CS:A、CS:C、CS:E。

程序中，我们用bx存放加2递增的偏移地址，用循环来进行累加。
在循环开始前，设置(bx)=0，cs:bx指向第一个数据所在的字单元。 
每次循环中(bx)=(bx)+2，cs:bx指向下一个数据所在的字单元。

上面的代码段, 在16个字节之后才是真正的执行部分, 那如何如何让这个程序在编译后可以存系统中直接运行呢？
我们可以在源程序中指明界序的入口所在，具体做法见下面的程序6.2。

```asm
assume cs:code
code segment
  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
  start: mov bx,0  ;指明程序入口
     	 mov ax,0
	     mov cx,8
      s: add ax,cs:[bx]
	     add bx,2
     	 loop s
	     mov ax,4c00h
     	 int 21h
code ends
end start    ;结束
```

注意在程序6.2中加入的新内容，我们在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现。
探讨end的作用：
end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。

有了这种方法，我们就可以这样来安排程序的框架:
```asm
assume cs:code
code segment
	     :
        数据
         :
start:
         :
        代码
         :
code ends
end start
```

## 6.2 在代码段中使用栈

完成下面的程序，利用栈，将程序中定义的数据逆序存放。 
   assume cs:codesg
   codesg segment
      dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
      ?
   code ends
   end

程序运行时，定义的数据存放在cs:0~cs:15单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这 8 个字单元中，从而实现数据的逆序存放。

问题是，我们首先要有一段可当作栈的内存空间。如前所述，这段空间应该由系统来分配。可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。 

```asm
assume cs:codesg
codesg segment
dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
start: mov ax,cs
	   mov ss,ax
	   mov sp,30h
	   mov bx,0
	   mov cx,8
s: push cs:[bx]
	   add bx,2
	   loop s
	   mov bx,0
       mov cx,8
s0: pop cs:[bx]
	   add bx,2
	   loop s0
	   mov ax,4c00h
	   int 21h
codesg ends
end start
```

dw可以说用它来定义数据, 也可以说用它来开辟内存空间.

## 6.3 将数据、代码、栈放入不同的段

在前面的内容中，我们在程序中用到了数据和栈，我们将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。

这样做显然有两个问题：
（1）把它们放到一个段中使程序显得混乱；
（2）前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中（一个段的容量不能大于64 KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样）。

所以，我们应该考虑用多个段来存放数据、代码和栈。

怎样做呢？
我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。具体做法如程序6.4所示，这个程序实现了和程序6.3 一样的功能，不同之处在于它将数据、栈和代码放到了不同的段中:

```asm
assume cs:code,ds:data,ss:stack
data segment
	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
data ends
stack segment
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
start:  mov ax,stack
		mov ss,ax
		mov sp,20h   ;设置栈顶ss:sp指向stack:20
		mov ax,data
		mov ds,ax    ;ds指向data段
		mov bx,0     ;ds:[bx]指向data段第一个单元
		mov cx,8
s: 		push [bx]
		add bx,2
		loop s    ;将data段数据入栈
		mov bx,0
		mov cx,8
s0: 	pop [bx]
		add bx,2
		loop s0
		mov ax,4c00h
		int 21h
code ends
end start
```

程序说明:

1. 定义多个段的方法

   跟定义一个段一样. 就是不同的段用不同的段名就行.`assume cs:code,ds:data,ss:stack`

2. 对段地址的引用

   在程序中, `段名`就相当于一个标号, 它`代表了段地址`. 所以`mov ax,data`就是把data段的段地址传给ax.

   程序中“data”段中的数据“0abch”的地址就是：data:6。我们要将它送入bx中，就要用如下的代码：
            mov ax,data
            mov ds,ax
            mov bx,ds:[6]
   我们不能用下面的指令：
            mov ds,data   
            mov ax,ds:[6]

   其中指令“mov ds,data” 是错误的，因为8086CPU不允许将一个数值直接送入段寄存器中。

   程序中对段名的引用，如指令“mov ds,data”中的“data”，将被编译器处理为一个表示段地址的数值。

3. “代码段”、“数据段”、“栈段”完全是我们的安排

   

# 第7章 更灵活的定位内存地址的方法

## 7.1 and和or指令

（1）and 指令：逻辑与指令，按位进行与运算。

​	通过该指令可将操作对象的相应位设为0，其他位不变。

（2）or 指令：逻辑或指令，按位进行或运算。

​	通过该指令可将操作对象的相应位设为1，其他位不变。

## 7.2 关于ASCII码

## 7.3 以字符形式给出的数据

在汇编程序中, 用'.....' 的方式知名数据是以字符的形式给出的, 编译器把他们转为相应的ASCII码值.

```asm
assume ds:data
data segment
 db 'unIX' 
 db 'foRK'
data ends
code segment
start:mov al,'a'
      mov bl,'b'
      mov ax,4c00h
      int 21h
code ends                     
end start                
```

db 'unIX' 相当于“db 75H,6EH,49H,58H”， “u”、 “n”、 “I”、 “X”的ASCII码分别为75H、6EH、49H、58H；

db 'foRK'相当于“db 66H,6FH,52H,4BH”， “f”、 “o”、 “R”、 “K”的ASCII码分别为66H、6FH、52H、4BH；

“mov al,’a’ ”相当于“mov al,61H”, ”a”的ASCII码为61H；
“mov al,’b’ ”相当于“mov al,62H”, ”b”的ASCII码为62H。

## 7.4 大小写转换的问题

大写     二进制             小写       二进制
 A         01000001          a         01100001
 B         01000010          b         01100010
 C         01000011          c         01100011
 D         01000100          d        01100100

大写的字母开头010 小写字母开头011

大小写转换就在于 该字节的第5权位上.

## 7.5 [bx+idata]

在前面，我们可以用[bx]的方式来指明一个内存单元， 我们还可以用一种更为灵活的方式来指明内存单元：
 [bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata（bx中的数值加上idata）。

我们看一下指令mov ax,[bx+200]的含义：
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。
数学化的描述为： (ax)=((ds)*16+(bx)+200)

指令mov ax,[bx+200]也可以写成如下格式（常用）：
 mov ax,[200+bx]
 mov ax,200[bx]
 mov ax,[bx].200

## 7.6 用[bx+idata]的方式进行数组的处理

有了[bx+idata]这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据。

在codesg中填写代码，将datasg中定义的第一个字符串，转化为大写，第二个字符串转化为小写。

assume cs:codesg,ds:datasg
datasg segment
db 'BaSiC'
db 'MinIX'
datasg ends

codesg segment
 start: ……
codesg ends
end start

这两个字符串在内存中的起始地址是不一样的，但是，它们中的每一个字符，从起始地址开始的相对地址的变化是相同的.

```asm
 mov ax,datasg
	mov ds,ax
	mov bx,0

	mov cx,5
s:	mov al,[bx]		;定位第一个字符串的字符
	and al,11011111b
	mov [bx],al
	mov al,[5+bx]	;定位第二个字符串的字符
	or al,00100000b
	mov [5+bx],al
	inc bx
	loop s
```

如果读者熟悉C语言的话，可以比较一下这个C程序和上面的汇编程序的相似之处。尤其注意它们定位字符串中字符的方式：

C语言定位方式：a[i]，b[i]
汇编语言定位方式：0[bx]，5[bx]

通过比较，我们可以发现：[bx+idata]的方式为高级语言实现数组提供了便利机制。 

## 7.7 SI和DI

SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成两个8 位寄存器来使用。

下面的三组指令实现了相同的功能：

```asm
（1）mov bx,0
     mov ax,[bx]
（2）mov si,0
     mov ax,[si]
（3）mov di,0
      mov ax,[di]

```

下面的三组指令也实现了相同的功能：

```asm
（1） mov bx,0
      mov ax,[bx+123]
（2） mov si,0
      mov ax,[si+123]
（3） mov di,0
      mov ax,[di+123]
```

> 以前只有[n] ,[ax] 等等, 现在可以[si] [di]了.

## 7.8 [bx+si]和[bx+di]

在前面，我们用[bx（si或di）]和[bx（si或di）+idata] 的方式来指明一个内存单元，我们还可以用更灵活的方式：
\[bx+si] \[bx+di]

[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)（即bx中的数值加上si中的数值）。

指令mov ax,[bx+si]的数学化的描述为：
      (ax)=( (ds)*16+(bx)+(si) )

该指令也可以写成如下格式（常用）：
       mov ax,\[bx][si] 

## 7.9 [bx+si+idata]和[bx+di+idata]

[bx+si+idata]表示一个内存单元, 它的偏移地址为(bx)+(si)+idata。（即bx中的数值加上si中的数值再加上idata）

指令mov ax,[bx+si+idata]的含义：
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。
 数学化的描述为： (ax)=( (ds)*16+(bx)+(si)+idata )

指令mov ax,[bx+si+idata]：
   该指令也可以写成如下格式（常用）：
```asm
mov ax,[bx+200+si] 
mov ax,[200+bx+si] 
mov ax,200[bx][si] 
mov ax,[bx].200[si] 
mov ax,[bx][si].200
```

## 7.10 不同的寻址方式的灵活应用

如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现有以下几种方式：
（1）[idata] 用一个常量来表示地址，可用于直接定位一个内存单元；
（2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；
（3）[bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
（4）[bx+si]用两个变量表示地址；
（5）[bx+si+idata] 用两个变量和一个常量表示地址。​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

这一章中，我们主要讲解了更灵活的寻址方式的应用和一些编程方法，主要内容有：
寻址方式
  [bx（或si、di）+idata]、 
  [bx+si（或di）]、
  [bx+si（或di）+idata]的意义和应用；
二重循环问题的处理；
栈的应用；
大小写转化的方法；
and 、or 指令

之所以如此重视这个问题，是因为寻址方式的适当应用，使我们可以以更合理的结构来看待所要处理的数据。\
而为所耍处理的看似杂乱的数据设计一种清晰的数据结构是程序设计的一个关键的问题。

# 第8章 数据处理的两个基本问题

本章对前面的所有内容是具有总结性的。我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：
（1）处理的数据在什么地方？
（2）要处理的数据有多长？

这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。 本章中，我们就要针对8086CPU对这两个基本问题进行讨论。虽然讨论是在8086CPU的基础上进行的，但是这两个基本问题却是普遍的，对任何一个处理器都存在。

我们定义的描述性符号：reg和sreg 

为了描述上的简洁，在以后的课程中，我们将使用两个描述性的符号 reg来表示一个寄存器，用sreg表示一个段寄存器。

reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；

sreg的集合包括：ds、ss、cs、es。

## 8.1 bx、si、di、bp

前三个寄存器我们己经用过了，现在我们进行一下总结。
（1）在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中来进行内存单元的寻址。

正确的指令
 mov ax,[bx]
 mov ax,[bx+si]
 mov ax,[bx+di]
 mov ax,[bp]
 mov ax,[bp+si]
 mov ax,[bp+di]

错误的指令
  mov ax,[cx]
  mov ax,[ax]
  mov ax,[dx]
  mov ax,[ds]

（2）在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：
bx和si、bx和di、bp和si、bp和di

正确用法:

 mov ax,[bx]
 mov ax,[si]
 mov ax,[di]
 mov ax,[bp]
 mov ax,[bx+si]
 mov ax,[bx+di]

 mov ax,[bp+si]
 mov ax,[bp+di]
 mov ax,[bx+si+idata]
 mov ax,[bx+di+idata]
 mov ax,[bp+si+idata]
 mov ax,[bp+di+idata]

错误的用法
   mov ax,[bx+bp]
   mov ax,[si+di]

（3）只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中。比如：

mov ax,[bp]               含义： (ax)=((ss)*16+(bp))
mov ax,[bp+idata]      含义：(ax)=((ss)*16+(bp)+idata)
mov ax,[bp+si]           含义：(ax)=((ss)*16+(bp)+(si))
mov ax,[bp+si+idata]  含义：(ax)=((ss)*16+(bp)+(si)+idata)

## 8.2 机器指令处理的数据所在位置

绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：
读取、写入、运算

在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置.

指令在执行前，所要处理的数据可以在三个地方：
   CPU内部、内存、端口

![1672577952586](Asm_lang.assets/1672577952586.png)

## 8.3 汇编语言中数据位置的表达

汇编语言中用三个概念来表达数据的位置。 (可以结合组成原理的数据寻址方式)
1、立即数（idata）
2、寄存器
3、段地址（SA）和偏移地址（EA）

1、立即数（idata）
   对于直接包含在机器指令中的数据（执行前在cpu 的指令缓冲器中），在汇编语言中称为：立即数（idata ) ，在汇编指令中直接给出。例如：
```asm
mov ax,1
add bx,2000H
or  bx,00010000b
mov al,'a'
```

2、寄存器
   指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：

```asm
mov ax,bx
mov ds,ax
push bx
mov ds:[0],bx
push ds
mov ss,ax
mov sp,bx
```

3、段地址（SA）和偏移地址（EA）
   指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。

存放段地址的寄存器可以是默认的, 比如:

```asm
mov ax,[0]
mov ax,[di]
mov ax,[bx+8]
mov ax,[bx+si]
mov ax,[bx+si+8]
```

上面这几个段地址在ds.

```asm
mov ax,[bp]
mov ax,[bp+8]
mov ax,[bp+si]
mov ax,[bp+si+8]
```

上面这几个段地址默认在ss中.

存放段地址的寄存器也可以显性的给出, 比如:

```asm
mov ax,ds:[bp]
mov ax,es:[bx]
mov ax,ss:[bx+si]
mov ax,cs:[bx+si+8]
```

## 8.4 寻址方式

当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。

![1672578733055](Asm_lang.assets/1672578733055.png)

## 8.5 指令要处理的数据有多长

8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。

（1）通过寄存器名指明要处理的数据的尺寸

下面的指令中，寄存器指明了指令进行的是字操作：
 mov ax,1
 mov bx,ds:[0]
 mov ds,ax
 mov ds:[0],ax
 inc ax
 add ax,1000

下面的指令中，寄存器指明了指令进行的是字节操作：
 mov al,1
 mov al,bl
 mov al,ds:[0]
 mov ds:[0],al
 inc al
 add al,100

（2）在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte

下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元：
 mov word ptr ds:[0],1
 inc word ptr [bx]
 inc word ptr ds:[0]
 add word ptr [bx],2

下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元：
 mov byte ptr ds:[0],1
 inc byte ptr [bx]
 inc byte ptr ds:[0]
 add byte ptr [bx],2

在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度是很必要的。
否则，CPU无法得知所要访问的单元是字单元，还是字节单元。

（3）其他方法

有些指令默认了访问的是字单元还是字节单元, 比如：push [1000H]就不用指明访问的是字单元还是字节单元，
因为push指令只进行字操作。

## 8.6 寻址方式的综合应用

我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。

使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。

从上面我们可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组（字符串）。

一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。

用bx定位整个结构体，用idata定位结构体中的某一个数据项，用 si 定位数组项中的每个元素 。
为此，汇编语言提供了更为贴切的书写方式。如：[bx].idata、[bx].idata[si]。

在C语言程序中我们看到，如：dec.cp[i]，dec是一个变量名，指明了结构体变量的地址，cp 是一个名称，指明了数据项cp的地址，而i用来定位cp中的每一个字符。
汇编语言中的做法是：bx.10h[si]

## 8.7 div 指令

div是除法指令(division)，使用div作除法的时候要注意:

(1) 除数:有8位和16位两种, 在一个reg或内存单元中.

(2) 被除数: 默认放在AX或DX和AX中, 若除数为8位, 被除数则为16位, 默认在AX中存放; 若除数为16位, 则被除数为32位, 在DX和AX中存放, DX存放高16位, AX放低16位.

(3) 结果: 若除数为8位, 则AL存储除法操作的商, AH存储除法操作的余数; 若除数是16位, 则AX存储除法操作的商, DX存储除法操作的余数.

div指令格式：
div reg
div 内存单元

现在我们可以用多种方法来表示一个内存单元了。

div byte ptr ds:[0]
含义为：`(al) = (ax) / ((ds)*16+0)的商`
  	       ` (ah) = (ax) / ((ds)*16+0)的余数`

div word ptr es:[0]
含义为：
  ` (ax) = [(dx)*10000H+(ax)]/((es)*16+0)的商`；
  `(dx) = [(dx)*10000H+(ax)]/((es)*16+0)的余数`

div byte ptr [bx+si+8]
  `(al)= (ax)/((ds)*16+(bx)+(si)+8)的商`
  `(ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数`

div word ptr [bx+si+8]
   `(ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商`；
   `(dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数`

编程：
   利用除法指令计算100001/100。

首先分析一下，被除数 100001 大于65535，不能用ax寄存器存放，所以我们要用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。

除数100小于255，可以在一个 8位寄存器中存放，但是，因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。 

因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为十六进制形式：186A1H。

程序如下:

```asm
mov dx,1
mov ax,86A1H  ;(dx)*10000H+(ax)=100001
mov bx,100
div bx
```

程序执行后，(ax)=03E8H（即1000），(dx)=1（余数为1）。

编程实现2：
    利用除法指令计算1001/100。
    我们首先分析一下被除数1001可用 ax寄存器存放，除数100可用 8位寄存器存放，也就是说，要进行8位的除法。程序如下： 
      mov ax,1001
      mov bl,100
      div bl
	程序执行后，(al)=0AH（即10），(ah)=1（余数为1）。

## 8.8 伪指令 dd

前面我们用db和dw定义字节型数据和字型数据。
dd是用来定义dword （double word双字）型数据的。

data segment
     db 1
     dw 1
     dd 1
data ends

在data段中定义了三个数据：
第一个数据为01H，在data:0处，占1个字节；
第二个数据为0001H，在data:1处，占1个字；
第三个数据为00000001H，在data:3处，占2个字节；

问题8.1
用div 计算data段中第一个数据除以第二个数据后的结果，商存放在第3个数据的存储单元中。 
      data segment
        dd 100001
        dw 100
        dw 0
      data ends

data段中的第一个数据是被除数，为dword（双字）型，32位，所以在做除法之前，用dx和ax存储。应将data:0字单元中的低16位存储在 ax中，data:2字单元中的高16位存储在dx中。

```asm
 mov ax,data
 mov ds,ax
 mov ax,ds:[0]        ;ds:0字单元中的低16位存储在ax中
 mov dx,ds:[2]        ;ds:2字单元中的高16位存储在dx中
 div word ptr ds:[4]  ;用dx:ax中的32位数据除以ds:4字
			          ;单元中的数据
 mov ds:[6],ax         ;将商存储在ds:6字单元中

```

## 8.9 dup

dup是一个操作符，在汇编语言中同db、dw、dd 等一样，也是由编译器识别处理的符号。
它是和db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。比如:

db 3 dup (0)    定义了3个字节，它们的值都是0，
相当于 db 0,0,0

db 3 dup (0,1,2)  定义了9个字节，它们是0、1、2、0、1、2、0、1、2，
相当于 db 0,1,2,0,1,2,0,1,2

db 3 dup (‘abc’,’ABC’)  定义了18个字节，它们是
   ‘abcABCabcABCabcABC’，
   相当于db ‘abcABCabcABCabcABC’

可见，dup的使用格式如下：
db 重复的次数 dup （重复的字节型数据）
dw 重复的次数 dup （重复的字型数据）
dd 重复的次数 dup （重复的双字数据）

# 第9章 转移指令的原理

可以修改IP, 或同时修改CS和IP的指令统称为 转移指令. 概括来说, 转移指令就是可以控制CPU执行内存中某处代码的指令.

8086CPU的转移行为有以下几类:

- 只修改ip, 称为段内转移, 比如 jmp ax
- 同时修改CS ip,称为段间转移, 如jmp 1000:0

由于转移指令对IP的修改范围不同,段内转移又分为: 短转移和近转移.

- 短转移IP范围: \-128\~127
- 近转移ip范围:\-32768\~32767

8086CPU的转移指令分为以下几类：
       无条件转移指令 （如：jmp）
       条件转移指令
       循环指令（如：loop）
       过程
       中断

## 9.1 操作符offset

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。
比如下面的程序：

```asm
assume cs:codesg
codeseg segment

    start:mov ax,offset start ; 相当于 mov ax,0
        s:mov ax,offset s      ; 相当于mov ax,3
codesg ends
end start

```

上面代码中 offset操作符取得了标号start和s的偏移地址0与3.

## 9.2 jmp指令

jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP；

jmp指令要给出两种信息：
转移的目的地址
转移的距离（段间转移、段内短转移，段内近转移）

不同的给出目的地址的方法, 和不同的转移位置, 对应有不同格式的jmp指令.

## 9.3 依据位移进行转移的jmp指令

`jmp short 标号（转到标号处执行指令）`

这种格式的 jmp 指令`实现的是段内短转移`，它对IP的修改范围为 -128\~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。

jmp指令中的 `short` 符号, 说明指令进行的是短转移. jmp指令中的` 标号 `, 是代码段中的标号, 指明了指令要转移的目的地, 转移后, CS:IP应该指向标号处的指令.

程序9.1

```asm
assume cs:codesg
codesg segment
  start:mov ax,0
        jmp short s
        add ax,1
      s:inc ax
codesg ends
end start

```

左面的程序执行后， ax中的值为 1 ，因为执行  jmp short s 后 ，越过了add ax,1 ，IP 指向了标号 s处的 inc ax。也就是说，程序只进行了一次ax加1操作。

汇编指令jmp short s 对应的机器指令应该是什么样的呢？

jmp 0008 （ Debug 中的表示）或jmp short  s （汇编语言中的表示）所对应的机器码为EB 03，注意，这个机器码中竟不包含转移的目的地址。

这意味着，CPU 在执行EB 03的时候，并不知道转移目的地址。

如果机器指令中不包含目的地址的话，那么，也就是说 CPU不需要这个目的地址就可以实现对IP的修改。

![1672742155660](Asm_lang.assets/1672742155660.png)

jmp short s指令的读取和执行过程：
（1）(CS)=0BBDH，(IP)=0006，CS:IP指向EB 03（jmp short s的机器码）；
（2）读取指令码EB 03进入指令缓冲器；
（3）(IP)=(IP)+所读取指令的长度=(IP)+2=0008，CS:IP指向add ax,1；
（4）CPU指行指令缓冲器中的指令EB 03；
（5）指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax

CPU执行 EB 03就是根据这个 03 才修改的IP, 执行EB03时 (ip)=0008H. 在转移指令中, EB03没有告诉CPU要转的目的地, 而是告诉CPU要转的位移量是多少. EB03告诉CPU往后位移3个字节.

> 所以在`jmp  short 标号`指令对应的机器码中, 不包含转移的目的地址, 而是包含转移的位移量. 而这个位移就是编译器根据`标号`计算出来的.

![1672742657715](Asm_lang.assets/1672742657715.png)

实际上，`指令“jmp short 标号”的功能为(IP)=(IP)+8位位移`。
（1）8位位移=“标号”处的地址-jmp指令后的第一个字节的地址；
（2）short指明此处的位移为8位位移；
（3）8位位移的范围为-128~127，用补码表示
     （如果你对补码还不了解，请阅读附注2）
（4）8位位移由编译程序在编译时算出。

还有一种和指令“jmp short 标号”功能相近的指令格式：
   `jmp near ptr 标号`
   它实现的时段内近转移。

指令“jmp near ptr 标号”的功能为：
    `(IP)=(IP)+16位位移`。

指令“jmp near ptr 标号”的说明：
（1）16位位移=“标号”处的地址-jmp指令后的第一个字节的地址；
（2）near ptr指明此处的位移为16位位移，进行的是段内近转移；
（3）16位位移的范围为-32769\~32767，用补码表示；
（4）16位位移由编译程序在编译时算出。

## 9.4 转移的目的地址在指令中的jmp指令

前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前IP的转移位移。

指令 “`jmp far ptr 标号`”  实现的是段间转移，又称为远转移。

指令 “jmp far ptr 标号” 功能如下：
(CS)=标号所在段的段地址；
(IP)=标号所在段中的偏移地址。
far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

程序9.3

```asm
assume cs:codesg
codesg segment
   start:mov ax,0
         mov bx,0
         jmp far ptr  s
         db 256 dup (0)
      s: add ax,1
         inc ax
codesg ends
end start
```

![1672744079826](Asm_lang.assets/1672744079826.png)

源程序中的db 256 dup (0)，被Debug解释为相应的若干条汇编指令 。这不是关键，关键是，我们要注意一下jmp far ptr s所对应的机器码：EA 0B 01 BD 0B ，其中包含转移的目的地址。

“0B 01 BD 0B” 是目的地址在指令中的存储顺序，高地址的“BD 0B”是转移的段地址：0BBDH，低地址的“0B 01” 是偏移地址：010BH。

## 9.5 转移地址在寄存器中的jmp指令

指令格式：jmp 16位寄存器
功能：IP =（16位寄存器）
这种指令我们在前面的课程（参见2.11节）中已经讲过，这里就不再详述.

## 9.6 转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式：

（1） `jmp word ptr 内存单元地址（段内转移）`
功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

内存单元地址可用寻址方式的任一格式给出。

如:

mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
执行后，(IP)=0123H

或者

mov ax,0123H
mov [bx],ax
jmp word ptr [bx]
执行后，(IP)=0123H

（2）` jmp dword ptr 内存单元地址（段间转移）`
功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的**段地址**，低地址处是转移的目的**偏移地址**。
		(CS)=(内存单元地址+2)
		(IP)=(内存单元地址)
    内存单元地址可用寻址方式的任一格式给出。

比如:

mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]

执行后，(CS)=0, (IP)=0123H, CS:IP 指向 0000: 0123.

又比如:

mov ax,0123H
mov [bx],ax
mov word ptr [bx+2],0
jmp dword ptr [bx]

执行后，(CS)=0, (IP)=0123H, CS:IP 指向 0000: 0123.

## 9.7 jcxz指令

jcxz指令为有条件转移指令，所有的有条件转移指令都是**短转移**，在对应的机器码中包含**转移的位移**，而不是目的地址。对IP的修改范围都为-128\~127。

指令格式：`jcxz 标号  `

（如果(cx)=0，则转移到标号处执行。）

操作：
当(cx)=0时，(IP)=(IP)+8位位移	
8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；
8位位移的范围为-128\~127，用`补码`表示；
8位位移由编译程序在编译时算出。

当(cx)不等于0时, 什么也不做(程序向下执行).

我们从 jcxz的功能中可以看出，指令“jcxz 标号”的功能相当于：
   if((cx)==0)  jmp  short 标号；

```asm
assume cs:code
code segment
  start: mov ax,2000h
         mov ds,ax
         mov bx,0
      s: mov ch,0
         mov cl,[bx]
         jcxz ok
         inc bx
      ok:mov dx,bx
mov 4c00h
int 21h;
code ends
end start
```

## 9.8 loop指令

loop指令为循环指令，所有的循环指令都是**短转移**，在对应的机器码中包含**转移的位移**，而不是目的地址。

对IP的修改范围都为-128\~127。

指令格式：loop 标号
    ((cx))=(cx)-1，如果(cx)≠0，转移到标号处执行。

操作：
（1）(cx)=(cx)-1;
（2）如果(cx)≠0，(IP)=(IP)+8位位移。
8位位移=“标号”处的地址-loop指令后的第一个字节的地址；
8位位移的范围为-128\~127，用补码表示；
8位位移由编译程序在编译时算出。

当(cx)=0，什么也不做（程序向下执行）。

我们从loop的功能中可以看出，指令“loop 标号”的功能相当于：
   (cx)--;
   if( (cx)≠0 )  jmp  short  标号;

```asm
assume cs:code
code segment
  start: mov ax,2000h
         mov ds,ax
         mov bx,0
      s: mov ch,0
         mov cl,[bx]
         inc cx
         inc bx
         loop s
      ok:dec bx
         mov dx,bx
mov 4c00h
int 21h;
code ends
end start
```

## 9.9 根据位移进行转移的意义

前面我们讲到：
     jmp short 标号
     jmp near ptr 标号
     jcxz 标号
     loop 标号

等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的`位移`来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的**位移距离**.

这样设计，方便了程序段在内存中的浮动装配。(组成原理)

```asm
汇编指令                             机器代码
mov cx,6                           B9 06 00
mov ax,10h                         B8 10 00
s: add ax,ax                       01 C0
   loop s                          E2 FC
```

这段程序装在内存中的不同位置都可正确执行，因为 loop s 在执行时只涉及到 s的位移（ - 4，前移 4个字节，补码表示为FCH），而不是s的地址。

如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制；因为机器码中包含的是 s 的地址，如果 s 处的指令不在目的地址处，程序的执行就会出错。

而loop s的机器码中包含的是转移的位移，就不存在这个问题了；因为，无论 s处的指令的实际地址是多少，loop指令的转移位移是不变的。

## 9.10 编译器对转移位移超界的检测

注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。

比如, 下面的程序将引起错误.

```asm
assume cs:code
code segment 
start: jmp short s
       db 128 dup (0)
    s: mov ax,0ffffh
code ends
end start
```

jmp short s的转移范围-128\~127. 128字节之后的内容, 跳不到.

我们在第2章中讲到的形如 “`jmp 2000:0100`”的转移指令，是在 `Debug 中`使用的汇编指令，汇编编译器并不认识。 如果在源程序中使用，编译时也会报错。

# 第10章 Call 和 Ret 指令

call和ret 指令都是转移指令，它们都修改IP，或同时修改CS和IP。

它们经常被共同用来实现子程序的设计.

## 10.1 ret 和 retf

ret指令用栈中的数据，修改IP的内容，从而实现近转移！

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；

CPU执行ret指令时，进行下面两步操作：
（1）(IP)=((ss)*16+(sp))
（2）(sp)=(sp)+2

CPU执行retf指令时，进行下面四步操作：
（1）(IP)=((ss)\*16+(sp))
（2）(sp)=(sp)+2
（3）(CS)=((ss)\*16+(sp))
（4）(sp)=(sp)+2

可以看出，如果我们用汇编语法来解释ret和retf指令，则：
CPU执行ret指令时，相当于进行：
 pop IP
CPU执行retf指令时，相当于进行：
 pop IP
 pop CS

## 10.2 call 指令

call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：
（1）将当前的 IP  或  CS和IP 压入栈中；
（2）转移（jmp）

call 指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。

下面的几个小节中 ，我们以给出转移目的地址的不同方法为主线，讲解call指令的主要应用格式。

## 10.3 依据位移进行转移的call指令

`call 标号`（将当前的 IP 压栈后，转到标号处执行指令）

CPU执行此种格式的call指令时，进行如下的操作：
(1) (sp) = (sp) – 2
      ((ss)*16+(sp)) = (IP)   ;当前IP压栈
(2) (IP) = (IP) + **16位位移** 

16位位移=“标号”处的地址－call指令后的第一个字节的地址；
16位位移的范围为 -32768~32767，用补码表示；
16位位移由编译程序在编译时算出。

从上面的描述中，可以看出，如果我们用汇编语法来解释此种格式的 call指令，则：
CPU 执行指令“call  标号”时，相当于进行：
        `push IP`
        `jmp near ptr 标号`         

## 10.4 转移的目的地址在指令中的call指令

前面讲解的call指令，其对应的机器指令中并没有转移的目的地址 ，而是相对于当前IP的**转移位移**。

指令“call far ptr 标号”实现的是段间转移。

CPU执行“call far ptr 标号”这种格式的call指令时的操作：
(1) (sp) = (sp) – 2
        ((ss) ×16+(sp)) = (CS) ; push CS
        (sp) = (sp) – 2
        ((ss) ×16+(sp)) = (IP)  ;push IP
(2) (CS) = 标号所在的段地址
    (IP) = 标号所在的偏移地址

从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的 call 指令，则：
CPU 执行指令 “call far ptr 标号” 时，相当于进行：
         push CS
         push IP
         jmp far ptr  标号

## 10.5 转移地址在寄存器中的call指令

指令格式：call 16位寄存器

功能：
(sp) = (sp) – 2
((ss)*16+(sp)) = (IP)  ;push IP
(IP) = (16位寄存器)   

汇编语法解释此种格式的 call 指令，CPU执行call 16位reg时，相当于进行：
           push IP 
           jmp 16位寄存器

## 10.6 转移地址在内存中的call指令

转移地址在内存中的call指令有两种格式：

 (1) call word ptr 内存单元地址
汇编语法解释：
   `push IP`
   `jmp word ptr 内存单元地址`
 (2) call dword ptr 内存单元地址

汇编语法解释：
       `push CS`
       `push IP`
      ` jmp dword ptr 内存单元地址`

## 10.7 call 和 ret 的配合使用

```asm
assume cs:code
code segment
start:  mov ax,1
	    mov cx,3
     	call s
	    mov bx,ax	;(bx) = ?
     	mov ax,4c00h
     	int 21h
    s:  add ax,ax
     	loop s
	    ret
code ends
end start

```

我们发现，可以写一个具有一定功能的程序段，我们称其为**子程序**，在需要的时候，用call指令转去执行。

上面s标号后面的就可以看做是一个子程序, call s 去调用它, 执行完ret再回去主程序执行.

可是执行完子程序后，如何让CPU接着call指令向下执行？

call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用 ret 指令，用栈中的数据设置IP的值，从而转到 call 指令后面的代码处继续执行。

> 前面知道了, call 就是push ip或者push cs push ip+jmp. 而ret 就是pop, 把之前的地址出栈, 再回去接着执行.

这样，我们可以利用call和ret来实现子程序的机制。 子程序的框架如下:

标号:
​	指令
​	ret

有子程序的源程序的框架如下:
```asm
assume cs:code
code segment
main:
	...
	...
	call sub1  ;调用子程序sub1
	...
	...
	mov ax,4c00h
	int 21h
sub1:        ;子程序1开始
    ...
    ...
    call sub2 ;调用子程序sub2
    ...
    ret       ;子程序返回
sub2:         ;子程序sub2开始
	...
	...
	ret       ;子程序返回
code ends
end main
```

## 10.8 mul 指令

因下面要用到，我们介绍一下mul指令，mul是乘法指令，使用 mul 做乘法的时候：

(1)相乘的两个数：**要么都是8位，要么都是16位**。

若是8 位： 一个默认放AL中,另一个放 8位寄存器或内存字节单元中；

若是16位: 一个默认放在ax中, 另一个放在16位reg或内存字单元中.

(2)结果
     8位乘法：结果默认放AX中；
   16位乘法：结果放 DX（高位）和AX（低位）中。

格式如下：
 `mul reg`
 `mul 内存单元`

`内存单元`可以用不同的寻址方式给出，比如：
`mul byte ptr ds:[0]`
  含义为： `(ax)=(al)*((ds)*16+0)`；

`mul word ptr [bx+si+8]`
   含义为： 
   `(ax)=(al)*((ds)*16+(bx)+(si)+8)`结果的低16位；
   `(dx)=(al)*((ds)*16+(bx)+(si)+8)`结果的高16位；

例如：
（1）计算100*10
   100和10小于255，可以做8位乘法，程序如下：
        mov al,100
         mov bl,10
         mul bl

​      结果： (ax)=1000（03E8H） 

又例如：
（2）计算100*10000
   100小于255，可10000大于255，所以必须做16位乘法，程序如下：
        mov ax,100
         mov bx,10000
         mul bx

​      结果： (ax)=4240H，(dx)=000FH
​               （F4240H=1000000）

## 10.9 模块化程序设计

从上面我们看到 ，call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。

因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。

而call和ret 指令对这种分析方法提供了程序实现上的支持。利用 call和ret指令，我们可以用简洁的方法，实现多个互相联系、功能独立的子程序来解决一个复杂的问题。

下面的内容中，我们来看一下子程序设计中的相关问题和解决方法。

## 10.10 参数和结果传递的问题

子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者。

其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。 

我们设计一个子程序，可以根据提供的N，来计算N的3次方。

这里有两个问题：
（1）我们将参数N存储在什么地方？
（2）计算得到的数值，我们存储在什么地方？

很显然，我们可以用寄存器来存储，可以将参数放到 bx 中 ；
因为子程序中要计算 N×N×N ，可以使用多个 mul 指令，为了方便，可将结果放到 dx 和 ax中。

```asm
;说明：计算N的3次方
;参数： (bx)=N
;结果： (dx:ax)=N∧3
  cube: mov ax,bx
   		mul bx
   		mul bx
   		ret
```

注意，我们在编程的时候要注意良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。

因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，所以一定要有全面的说明。

用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：
调用者将参数送入参数寄存器，从结果寄存器中取到返回值；
子程序从参数寄存器中取到参数，将返回值送入结果寄存器。 

编程：计算data段中第一组数据的 3 次方，结果保存在后面一组dword单元中。
```asm
assume cs:code
data segment
  dw 1,2,3,4,5,6,7,8
  dd 0,0,0,0,0,0,0,0
data ends
code segment
  start: mov ax,data
  		 mov ds,ax
  		 mov si,0
  		 mov di,16
  		 
  		 mov cx,8
  	  s: mov bx,[si] ;第一组要计算的数据
         call cube
         mov [di],ax
         mov [di+2],dx
         add si,2      ;下一个数据
         add di,4      ;下一个dword单元
         loop s
         mov ax,4c00h
		 int 21h
   cube: mov ax,bx
   		 mul bx
   		 mul bx
   		 ret
 code ends
 end start
```

## 10.11 批量数据的传递

前面的例程中，子程序 cube 只有一个参数，放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个、4个或更多直至 N个，我们怎样存放呢？
寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。

在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。

对于具有批量数据的返回结果，也可用同样的方法。 

看个例子: 设计一个子程序, 功能:将一个全是字母的字符串转为大写.

这个子程序需知道两件事, 字符串的内容和字符串的长度. 因为字符串中的字母可能很多, 所以不便将整个字符串中的所有字母都直接传给子程序. 但可以把字符串在内存中的首地址放在寄存器中传给子程序. 因为子程序要用到循环, 我们可以把字符串长度放到cx寄存器中.

```asm
assume cs:code
data segment
 db 'conversation'
data ends

code segment
  start:mov ax,data
        mov ds,ax
        mov si,0
        mov cx,12
        call capital
        mov ax,4c00h
        int 21h
        
capital:and byte prt [si],11011111b
	    inc si
	    loop capital
	    ret
code ends
end start
```

注意：除了寄存器、内存传递参数外，还有一种通用的方法使用**栈**来传递参数。关于这种技巧请参看附注4。

## 10.12 寄存器冲突的问题

设计一个子程序：
功能：将一个全是字母，以0结尾的字符串，转化为大写。

程序要处理的字符串以0作为结尾符，这个字符串可以如下定义：
 db  ‘conversation’, 0

应用这个子程序 ，字符串的内容后面定要有一个0，标记字符串的结束。子程序可以依次读取每个字符进行检测，如果不是0，就进行大写的转化，如果是0，就结束处理。
由于可通过检测0而知道是否己经处理完整个字符串 ，所以子程序可以不需要字符串的长度作为参数。我们可以直接用jcxz来检测0。

```asm
;说明: 将一个全是字母, 以0为结尾的字符串, 转化为大写
;参数: ds:si指向字符串首地址
;结果: 无返回值
capital:mov ch,0
		mov cl,[si]
		jcxz ok
		and byte ptr [si],11011111b
		inc si
		jmp short capital
	ok: ret
```

子程序应用:

(1) 将data段里的字符串转化为大写

```asm
assume cs:code
data segment
 db 'agfagwagasg',0
data ends

code segment
  start: mov ax,data
         mov ds,ax
         mov si,0
         call capital
         mov ax,4c00h
         int 21h
 capital:mov ch,0
		 mov cl,[si]
		 jcxz ok
		 and byte ptr [si],11011111b
		 inc si
		 jmp short capital
	 ok: ret
```

(2) 将data段中字符串全部转化为大写

```asm
assume cs:code
  data segment
     db ‘word',0
     db ‘unix',0
     db ‘wind',0
     db ‘good',0
data ends

code segment
  start: mov ax,data
         mov ds,ax
         mov bx,0
         mov cx,4
      s: mov si,bx
         call capital
         add bx,5
         pop cx
         loop s
         
         mov ax,4c00h
         int 21h
 capital:push cx
 		 push si
 		 mov ch,0
		 mov cl,[si]
		 jcxz ok
		 and byte ptr [si],11011111b
		 inc si
		 jmp short capital
	 ok: pop si
	 	 pop cx
	 	 ret
```

# 第11章 标志寄存器

CPU内部的寄存器中, 有一种特殊的寄存器(对不同的处理机, 个数和结构都可能不同), 具有以下三种作用.

(1) 用来存储相关指令的某些执行结果;

(2) 用来为CPU执行相关指令提供判据;

(3) 用来控制CPU的相关工作方式.

这种特殊的寄存器在8086CPU中, 被称为标志寄存器. 8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）。我们己经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、ip、cs、ss、ds、es等13个寄存器了。本章中的标志寄存器（以下简称为flag）是我们要学习的最后一个寄存器。

flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的**每一位都有专门的含义**，记录特定的信息。

![1672841351403](Asm_lang.assets/1672841351403.png)

flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。

## 11.1 ZF标志

flag的第6位是ZF，零标志位。
它记录相关指令执行后，若结果为0 ，ZF = 1, 若结果不为0，ZF = 0. 

例如：
     mov ax,1
     sub ax,1  
   指令执行后，结果为0，则ZF = 1。
	mov ax,2
	sub  ax,1 
   指令执行后，结果为1，则ZF = 0。

注意：
在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是**运算指令**（进行逻辑或算术运算）；

有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是**传送指令**。

在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标记寄存器的哪些标志位造成影响。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

## 11.2 PF标志

flag的第2位是PF，奇偶标志位。
它记录相关指令执行后，结果的所有二进制位中1的个数：
为偶数，PF = 1；
为奇数，PF = 0。

比如, 指令：
mov al,1
add al,10
执行后，结果为00001011B，其中有3（奇数）个1，则PF=0；

指令：
mov al,1
or al,10
执行后，结果为00000011B，其中有2（偶数）个1，则PF=1；

## 11.3 SF标志

flag的第7位是SF，符号标志位。它记录相关指令执行后，
结果为负，SF = 1；
结果为非负，SF = 0。

计算机中通常用补码来表示有符号数据. 计算机中的一个数据可以看做是有符号数, 也可以看做无符号数, 比如:

00000001B, 可以看做无符号数1, 或有符号数+1.
10000001B, 可以看做无符号数129, 或者有符号数-127

mov al,10000001B
add al,1
结果： (al)=10000010B

可以将add指令进行的运算当作无符号数的运算，那么add指令相当于计算129+1，结果为130（10000010B）；

也可以将add指令进行的运算当作有符号数的运算，那么add指令相当于计算-127+1，结果为-126（10000010B）。

不管我们如何看待，CPU 在执行add等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。
关键在于我们的程序需要哪一种结果。

SF 标志，就是CPU对有符号数运算结果的一种记录 ，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。

这也就是说，CPU在执行 add 等指令时，是必然要影响到SF标志位的值的。
至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。

mov al,10000001B
add al,1

执行后，结果为10000010B，SF=1，
表示：如果指令进行的是有符号数运算，那么结果为负；

mov al,10000001B
add al,01111111B
执行后，结果为0，SF=0. 表示: 如果指令进行的是有符号数运算，那么结果为非负。

某此指令将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。
比如指令sub al,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。

## 11.4 CF标志

flag的第0位是CF，进位标志位。

一般情况下，在进行**无符号数**运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。

![1672899935103](Asm_lang.assets/1672899935103.png)

我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。

比如，两个8 位数据：98H+98H，将产生进位。
由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了. 其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU 就用flag的CF位来记录这个进位值。比如:

```asm
mov al,98h
add al,al ;执行后 (al)=30h, CF=1, 进位保存到CF中了.
add al,al ;执行完 (al)=60h, cf=0, 这次add没产生进位
```

另外一种情况，而当两个数据做减法的时候，有可能向更高位借位。
比如，两个 8 位数据：97H-98H，将产生借位，借位后，相当于计算197H-98H。
而flag的CF位也可以用来记录这个借位值。

```asm
mov al,97h
sub al,98h  ;执行后(al)=FFH, CF=1, cf记录向跟高位的借位值
sub al,al  ;执行后 (al)=0,CF=0
```

在Debug中，我们可以看到类似下面的信息：

![1672901020529](Asm_lang.assets/1672901020529.png)

![1672901027634](Asm_lang.assets/1672901027634.png)

## 11.5 OF标志

我们先来谈谈溢出的问题。
在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。

那么，什么是机器所能表示的范围呢？

比如：add al, 3，那么对于 8 位的有符号数据，机器所能表示的范围就是-128~127。

如果运算结果超出了机器所能表达的范围，将产生溢出。
注意，这里所讲的溢出，只是对有符号数运算而言。（就像进位只是相对于无符号数而言！）

mov al,98

add al,99

这俩语句肯定溢出, (al)=0C5H ，因为进行的是有符号数运算，所以 al中存储的是有符号数，而0C5H是有符号数-59的补码。

由于在进行有符号数运算时，可能发生溢出而造成结果的错误。所以CPU需要对指令执行后是否产生溢出进行记录。因此有了OF.

flag寄存器的第11位是OF, 溢出标志位. 一般情况下, OF记录了有符号数运算的结果是否发生了溢出. 若发生溢出, OF=1; 否则, OF=0. 

记住，一定要注意CF和OF的区别：
**CF是对无符号数运算有意义的标志位**；
**而OF是对有符号数运算有意义的标志位。**

CPU在执行add等指令时, 就包含了两种含义: 无符号数运算与有符号数运算.

对于无符号数运算，CPU用CF位来记录是否产生了进位；
对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出，
当然，还要用SF位来记录结果的符号。

执行
mov al,98
add al,99
后, CF=0, 因为无符号数的话, 就没进位. OF=1, 若是有符号数运算的话, 那就溢出了.

同样的, 

执行 mov al, 0F0h  add al, 88H 后, CF=1, OF =1; 对无符号数, 有进位. 对有符号数, 有溢出.

```asm
mov al,0F0h
add al,78h
```

执行后, CF=1, OF=0

对于有无符号，计算机是分不清楚状况的，因此他必须两种都记载着，要怎么用，看的是你当他是什么！

## 11.6 adc指令

adc是带进位加法指令 ，它利用了CF位上记录的进位值。
格式：adc  操作对象1,操作对象2
功能： 操作对象1=操作对象1+操作对象2+CF
比如：adc ax,bx 实现的功能是：
   (ax)=(ax)+(bx)+CF

mov ax,2 
mov bx,1 
sub bx,ax 
adc ax,1
执行后，(ax)=4。
adc执行时，相当于计算： (ax)+1+CF=2+1+1=4。

mov ax,1 
add ax,ax 
adc ax,3
执行后，(ax)=5。
adc执行时，相当于计算： (ax)+3+CF=2+3+0=5。

mov al,98H 
add al,al
adc al,3
执行后，(ax)=34H。
adc执行时，相当于计算： (ax)+3+CF=30H+3+1=34H。

在执行 adc 指令的时候加上的 CF 的值的含义，由 adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。

显然，如果CF 的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。

我们来看一下两个数据：0198H和0183H如何相加的：
   01 98 
\+ 01 83 
     1
\-----------------
   03 1B

可以看出，加法可以分两步来进行：
（1）低位相加；
（2）高位相加再加上低位相加产生的进位值。

下面的指令和add ax , bx具有相同的结果：
```asm
add al,bl 
adc ah,bh
```

看来CPU提供 adc 指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。 看个例子:

编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。

```asm
mov ax,001EH
mov bx,0F000H
add bx,1000H
adc ax,0020H 
```

adc 指令执行后，也可能产生进位值，所以也会对CF位进行设置。由于有这样的功能，我们就可以对任意大的数据进行加法运算。 

例如，编程计算
1EF0001000H+2010001EF0H，结果放在ax（高16位），bx（次高16位），cx（低16位）中。

```asm
mov ax,001Eh
mov bx,0F000h
mov cx,1000h
add cx,1EF0H
adc bx,1000H
adc ax,0020H
```

下面我们，编写一个子程序，对两个128位数据进行相加。

名称：add128
功能：两个128位数据进行相加
参数：ds:si指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元，由低地址单元到高地址单元依次存放 128位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。

ds:di指向存储第二个数的内存空间

```asm
add128: push ax
		push cx
		push si
		push di
	   
	   	sub ax,ax
	   	mov cx,8
	 s: mov ax,[si]
	    adc ax,[di]
	    mov [si],ax
	    inc si
	    inc si
	    inc di
	    inc di
	    loop s
	   	pop di
	   	pop si
	   	pop cx
	   	pop ax
	   	ret
```

inc与loop 不影响CF位,  上面4个inc指令不能用add取代, 因为add会影响cf位.

## 11.7 sbb指令

sbb是带错位减法指令，它利用了CF位上记录的借位值。
格式：sbb  操作对象1,操作对象2
功能：操作对象1= 操作对象1–操作对象2–CF
比如：sbb ax,bx
实现功能： (ax) = (ax) – (bx) – CF

利用sbb指令我们可以对任意大的数据进行减法运算。

计算003E1000H–00202000H，结果放在ax，bx中，程序如下： 

```asm      
mov bx,1000H
mov ax,003EH
sub bx,2000H
sub ax,0020H
```

sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。在这里，我们就不再进行过多的讨论。
通过学习这两条指令，我们可以进一步领会一下标志寄存器CF位的作用和意义。

## 11.8 cmp指令

cmp 是比较指令，功能**相当于减法指令**，只是**不保存结果**。

cmp 指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。

cmp指令格式：cmp 操作对象1,操作对象2

功能：计算操作对象1–操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。

比如：cmp ax,ax
做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。

指令执行后：ZF=1，PF=1，SF=0，CF=0，OF=0。

下面的指令：
       mov ax,8
       mov bx,3
       cmp ax,bx

执行后： (ax) = 8, ZF=0，PF=1，SF=0，CF=0，OF=0。

其实，我们通过cmp 指令执行后，相关标志位的值就可以看出比较的结果。

例如：cmp ax,bx

![1672913957438](Asm_lang.assets/1672913957438.png)

现在我们可以看出比较指令的设计思路, 即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。

反过来看上面的例子 cmp ax,ax

![1672914093569](Asm_lang.assets/1672914093569.png)

同 add、sub 指令一样，CPU 在执行cmp指令的时候，也包含两种含义：
进行无符号数运算和进行有符号数运算。
所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。

下面我们再来看一下如果用cmp来进行**有符号数**比较时，我们要注意哪些标志位！

我们以cmp ah,bh为例进行说明：
   如果(ah)=(bh) 则(ah)-(bh)=0，所以：ZF=1；
   如果(ah)≠(bh) 则(ah)-(bh) ≠0，所以：ZF=0；

所以，我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。 

我们继续看，如果(ah)<(bh)则可能发生什么情况呢？

对于有符号数运算，在 (ah)＜(bh) 情况下，(ah)-(bh)显然可能引起SF=1，即结果为负。

比如：
(ah) = 1，(bh) = 2：
则(ah)-(bh)=0FFH，0FFH 为 -1 的补码，因为结果为负，所以SF=1。

(ah)=0FEH，(bx)=0FFH：
则(ah)-(bh)=(-2)-(-1)=0FFH，因为结果为负，所以SF=1。 

通过上面的例子，我们是不是可以得到这样的结论：
cmp 操作对象1,操作对象2 指令执行后，SF=1，就说明操作对象1＜操作对象2？
当然不是。

(ah)=22H，(bh)=0A0H：
则(ah)-(bh)=34-(-96)=130=82H，82H是   -126的补码，所以SF=1。
这里虽然SF=1，但是并不能说明(ah)<(bh)，因为显然34>-96。

两个有符号数A 和B 相减，得到的是负数，那么可以肯定A<B，这个思路没有错误；
关键在于我们根据什么来断定得到的是一个负数。
CPU将 cmp 指令得到的结果记录在flag的相关标志位中。

我们可以根据指令执行后，相关标志位的值来判断比较的结果。
单纯地考察SF 的值不可能知道结果的正负。因为SF 记录的只是可以在计算机中存放的相应位数的结果的正负。
比如add ah, al执行后，SF记录的是ah中的8位二进制信息所表示的数据的正负。

所得到的相应结果的正负，并不能说明，运算所应该得到的结果的正负。
这是因为在运算的过程中可能发生**溢出**。
如果有这样的情况发生，那么，SF的值就不能说明任何问题。 

如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。

所以，我们应该在考察**SF**（得知实际结果的正负）的同时考察**OF**（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。
下面，我们以cmp ah,bh为例，总结一下CPU执行cmp指令后，SF和OF的值是如何来说明比较的结果的。

（1）如果SF=1，而OF=0
OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因SF=1，实际结果为负，所以逻辑上真正的结果为负，所以(ah)<(bh)。 

（2）如果SF=1，而OF=1
OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；
简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。这样，SF=1，OF = 1 ，说明了(ah)>(bh)。 

（3）如果SF=0，而OF=1
OF=1 ，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；
简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，SF=0，OF = 1 ，说明了(ah)<(bh)。 

（4）如果SF=0，而OF=0
OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因SF=0，实际结果非负，所以逻辑上真正的结果必然非负。所以(ah)≥(bh)。

上面，我们深入讨论了cmp指令在进行有符号数和无符号数比较时，对flag 相关标志位的影响，和CPU如何通过相关的标志位来表示比较的结果。
在学习中，要注意领会8086CPU这种工作机制的设计思想。实际上，这种设计思想对于各种处理机来说是普遍的。